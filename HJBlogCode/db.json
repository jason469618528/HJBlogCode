{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/again/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/again/source/css/app.scss","path":"css/app.scss","modified":0,"renderable":1},{"_id":"themes/again/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/again/source/images/banner-small.png","path":"images/banner-small.png","modified":0,"renderable":1},{"_id":"themes/again/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/again/source/images/banner-large.png","path":"images/banner-large.png","modified":0,"renderable":1},{"_id":"source/img/1693553-0bed79c964adb6dc.png","path":"img/1693553-0bed79c964adb6dc.png","modified":0,"renderable":0},{"_id":"source/img/1693553-0ed0fdac87c08112.png","path":"img/1693553-0ed0fdac87c08112.png","modified":0,"renderable":0},{"_id":"source/img/1693553-98812f12b7414336.png","path":"img/1693553-98812f12b7414336.png","modified":0,"renderable":0},{"_id":"source/img/1693553-d8e6c07058f379f0-1.png","path":"img/1693553-d8e6c07058f379f0-1.png","modified":0,"renderable":0},{"_id":"source/img/277755-72008ba008a56557.png","path":"img/277755-72008ba008a56557.png","modified":1,"renderable":0},{"_id":"source/img/277755-e736892057d71333.png","path":"img/277755-e736892057d71333.png","modified":1,"renderable":0},{"_id":"source/img/277755-807a54b6dcbeb347.png","path":"img/277755-807a54b6dcbeb347.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"76e23586ff967efa3d738cca6c9a145d1e45d0b2","modified":1489729247000},{"_id":"themes/again/README.md","hash":"74eb9742c34d3630da066905bb955f249b9be1df","modified":1488440045000},{"_id":"themes/again/_config.yml","hash":"091e30c372a88ab34478bc93472537620a917297","modified":1488444016000},{"_id":"source/_images/.DS_Store","hash":"7fbca04a4fa3b185dd65799390cdaa507ff165fd","modified":1489728379000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1489724862000},{"_id":"source/_posts/IOS 开发经验总结(不定时更新).md","hash":"4fcd088c192b4b4283a9455417e438fbfb50aef3","modified":1490078296000},{"_id":"source/_posts/IOS面试题(初级).md","hash":"4bcc77446deb357ca50f41b9222777c00465a3e5","modified":1488506584000},{"_id":"source/_posts/Xcode 创建自定义模板 (网络).md","hash":"cc8913ee29a0227f85f432cc87a79c4943391d00","modified":1489729293000},{"_id":"source/_posts/使用SourceTree&Github 碰到的问题.md","hash":"780061171c36526af5f085a96313ddac9ccf3235","modified":1488447870000},{"_id":"themes/again/.git/FETCH_HEAD","hash":"355d7f481d62838664ea6451059a66e267d31a3e","modified":1488447895000},{"_id":"themes/again/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1488440045000},{"_id":"themes/again/.git/config","hash":"08e0b6b92c013d0b238258d3c3087e767acade11","modified":1488440045000},{"_id":"themes/again/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1488440021000},{"_id":"themes/again/.git/index","hash":"bb0f0a2f18c298ce2daa57bc2b61af95e40dba33","modified":1488447918000},{"_id":"themes/again/.git/packed-refs","hash":"a49162f50f6f47707fd2ed4e99ec9bafee24dda7","modified":1488440045000},{"_id":"themes/again/layout/archive.ejs","hash":"1f8724a48ab2ef61182b8a930e3998f833eb1487","modified":1488440045000},{"_id":"themes/again/layout/index.ejs","hash":"b87edba726df46b991bcaa153c1a222080f991e9","modified":1488440045000},{"_id":"themes/again/layout/layout.ejs","hash":"bfe888472313a2edc8b7db3190b1802d580fc2bd","modified":1488440045000},{"_id":"themes/again/layout/page.ejs","hash":"b1c9235cd9ccff78c4dc15608a708e4a74433d46","modified":1488440045000},{"_id":"themes/again/layout/post.ejs","hash":"fa55c7bed8d3ac20e3911140d5252b9184ca3b14","modified":1488440045000},{"_id":"themes/again/source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1488445031000},{"_id":"themes/again/source/favicon.ico","hash":"a802ff961c5055bb3e9c9c20cd99266eff681ccd","modified":1488444948000},{"_id":"source/_images/Xcode 创建自定义模板 (来源网络)/1693553-0bed79c964adb6dc.png","hash":"61048cbd4105d38d09fc92126cccde77feb76d0f","modified":1489722636000},{"_id":"source/_images/Xcode 创建自定义模板 (来源网络)/1693553-0ed0fdac87c08112.png","hash":"1f371f56e6b605b79d49fb96f6157716ebeb2e3f","modified":1489722821000},{"_id":"themes/again/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1488440021000},{"_id":"themes/again/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1488440021000},{"_id":"themes/again/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1488440021000},{"_id":"themes/again/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1488440021000},{"_id":"themes/again/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1488440021000},{"_id":"themes/again/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1488440021000},{"_id":"themes/again/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1488440021000},{"_id":"themes/again/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1488440021000},{"_id":"themes/again/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1488440021000},{"_id":"themes/again/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1488440021000},{"_id":"themes/again/.git/logs/HEAD","hash":"85b0439490488fd58ae90f46b051a3f356983726","modified":1488440045000},{"_id":"themes/again/layout/_partial/archive.ejs","hash":"6171678e54aec97bf3de20f2a0a81566b9e4ce3a","modified":1488447923000},{"_id":"themes/again/layout/_partial/article.ejs","hash":"76e490830f562699b4ddc01c6df6e7f89f0414e3","modified":1488447923000},{"_id":"themes/again/layout/_partial/footer.ejs","hash":"8b298f7a91ed927309e2436df3a291a87edaed67","modified":1488443981000},{"_id":"themes/again/layout/_partial/head.ejs","hash":"cecf7512f9c5a586058d18faf4b881169fc202cf","modified":1488440045000},{"_id":"themes/again/layout/_partial/header.ejs","hash":"219c66b37b46bad660099e1516dbb6dcbab0a992","modified":1488440045000},{"_id":"themes/again/layout/_partial/index.ejs","hash":"2d89dd44e2acfdda48c5ecabf06e25a9501c4be3","modified":1488447921000},{"_id":"themes/again/layout/_partial/nav.ejs","hash":"9145acd2c9f3fcb5d1ed3d63ad6ad4b8a075b734","modified":1488440045000},{"_id":"themes/again/layout/_widget/back-to-home.ejs","hash":"6d3544def976676e38e10134cae071f44bbf67d7","modified":1488440045000},{"_id":"themes/again/layout/_widget/disqus.ejs","hash":"47eb63418da61245bf674cb1764419c2741e486b","modified":1488440045000},{"_id":"themes/again/layout/_widget/paginator.ejs","hash":"ed04dbcb0cc79733ac338c3fc2a8604d41eb0848","modified":1488440045000},{"_id":"themes/again/layout/_widget/sharing.ejs","hash":"8d50310cae2bd6531a3ba04b5c5188c616035359","modified":1488440045000},{"_id":"themes/again/layout/_widget/twitter.ejs","hash":"49acef5c7713af0dc27f3aa78b80cb6379d18262","modified":1488444239000},{"_id":"themes/again/source/css/_base.scss","hash":"efeb11d16ab4cf79e67ffac179e41ddfba82aac0","modified":1488440045000},{"_id":"themes/again/source/css/_font.scss","hash":"3348cde2f82797bd92ab69405824f02472736698","modified":1488440045000},{"_id":"themes/again/source/css/_variables.scss","hash":"e649d7f3a0323d8742b9ef9fdd2b6cf458025bce","modified":1488447917000},{"_id":"themes/again/source/css/app.scss","hash":"7b466635119bfb88c54532f4f88b8f824b5a6666","modified":1488440045000},{"_id":"themes/again/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1488445007000},{"_id":"themes/again/source/images/avatar.png","hash":"a802ff961c5055bb3e9c9c20cd99266eff681ccd","modified":1488444948000},{"_id":"themes/again/source/images/banner-small.png","hash":"4b87b439bbf9507f7bed53d7c2c1a22e07a064e8","modified":1488440045000},{"_id":"themes/again/source/js/app.js","hash":"8e00097211a064209ae0e9fb556920673f5b9a42","modified":1488440045000},{"_id":"source/_images/Xcode 创建自定义模板 (来源网络)/1693553-98812f12b7414336.png","hash":"bce484757d70893de0eb65620cc5ae985ab84d81","modified":1489722708000},{"_id":"source/_images/Xcode 创建自定义模板 (来源网络)/1693553-d8e6c07058f379f0-1.png","hash":"33c3582f02ae35647f3de888734c7af914a6f731","modified":1489722838000},{"_id":"themes/again/.git/objects/pack/pack-acf3e222c7f329aad4bf622dfd6625ba37b8ccc5.idx","hash":"d796886dff9d5b6fd0e18df0840b7f2b03a25390","modified":1488440045000},{"_id":"themes/again/.git/refs/heads/master","hash":"874843a486edd0e72e1e7d7e09fc0c7cd8bca61b","modified":1488440045000},{"_id":"themes/again/source/css/_helper/grid.scss","hash":"d290e1315dc8dc3509e26fb5e4ff55eb277e6e84","modified":1488440045000},{"_id":"themes/again/source/css/_helper/index.scss","hash":"8c35cff7ea4785042f6116f28b09ea8ffc087255","modified":1488440045000},{"_id":"themes/again/source/css/_partial/archive.scss","hash":"b358e1a0e51ebea6ea5aee80447644baaa463723","modified":1488440045000},{"_id":"themes/again/source/css/_partial/article.scss","hash":"d61138a0f5e59204a4f37d34e4bdf48157e78bbe","modified":1488440045000},{"_id":"themes/again/source/css/_partial/footer.scss","hash":"f1ecaa07e5920eede1c2e0b7bfbfe1b3a8f8fb5c","modified":1488440045000},{"_id":"themes/again/source/css/_partial/header.scss","hash":"e0d092a98d2c9822a31a4b93c1e31fca5d68af21","modified":1488440045000},{"_id":"themes/again/source/css/_partial/index.scss","hash":"7498f3c447a5510891fb880d685a39f4791550f0","modified":1488440045000},{"_id":"themes/again/source/css/_partial/nav.scss","hash":"d66e6ae75faaa0bf77c481264e9109714007b1f8","modified":1488440045000},{"_id":"themes/again/source/css/_partial/page.scss","hash":"b576caf22a0d0b9b872ad54dbd0ab2c16a104b86","modified":1488440045000},{"_id":"themes/again/source/css/_partial/partials.scss","hash":"5fd002673fcd254a600b0d034c9eba03033715a4","modified":1488440045000},{"_id":"themes/again/source/css/_widget/back-to-home.scss","hash":"d60425bff8e9cbed9f0f0a9827cbc567f994fb14","modified":1488440045000},{"_id":"themes/again/source/css/_widget/highlight.scss","hash":"433e8a1c04b6e0fe5617cdadc2e12762c337d7f9","modified":1488440045000},{"_id":"themes/again/source/css/_widget/index.scss","hash":"5de4195cf47963fe68a15e16b7bb067970e0b83c","modified":1488440045000},{"_id":"themes/again/source/css/_widget/sharing.scss","hash":"38f54a9aa48654e4dad44535918550098aa913a6","modified":1488440045000},{"_id":"themes/again/source/images/banner-large.png","hash":"3e91a135ca4c446301995aedc998784e035d485a","modified":1488440045000},{"_id":"themes/again/.git/logs/refs/heads/master","hash":"85b0439490488fd58ae90f46b051a3f356983726","modified":1488440045000},{"_id":"themes/again/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1488440045000},{"_id":"themes/again/.git/logs/refs/remotes/origin/HEAD","hash":"85b0439490488fd58ae90f46b051a3f356983726","modified":1488440045000},{"_id":"themes/again/.git/objects/pack/pack-acf3e222c7f329aad4bf622dfd6625ba37b8ccc5.pack","hash":"4fa373fea519f20555fcb4eb57b2dc65e1f09a2d","modified":1488440045000},{"_id":"public/2017/03/16/IOS 开发经验总结(不定时更新)/index.html","hash":"5a999a94403e828c5d17f9d3b64637155e135bc5","modified":1489723380863},{"_id":"public/2017/03/03/IOS面试题(初级)/index.html","hash":"b2b21cf0dfd92e819df874b1140e5a97dc1f9162","modified":1489723380870},{"_id":"public/2017/03/02/使用SourceTree&Github 碰到的问题/index.html","hash":"3cdc28949dcb98fdf327e7503aca097cfaa1f327","modified":1489723380871},{"_id":"public/archives/index.html","hash":"445859bd6cc5f659e031ec124d7534e0e769a626","modified":1492738824099},{"_id":"public/archives/2017/index.html","hash":"445859bd6cc5f659e031ec124d7534e0e769a626","modified":1492738824102},{"_id":"public/archives/2017/03/index.html","hash":"2f75cb607402bf9fbaf659b18b9ca0594d17784d","modified":1490078303570},{"_id":"public/index.html","hash":"319192b7340d2274efe62c6c2023908f71dbb2a8","modified":1492738824092},{"_id":"public/2017/03/17/Xcode 创建自定义模板 (网络)/index.html","hash":"0d76fef331aed4fc5211aa814a2534dffa0217b8","modified":1489729301241},{"_id":"public/favicon.ico","hash":"a802ff961c5055bb3e9c9c20cd99266eff681ccd","modified":1489723380880},{"_id":"public/images/avatar.png","hash":"a802ff961c5055bb3e9c9c20cd99266eff681ccd","modified":1489723380880},{"_id":"public/images/banner-small.png","hash":"4b87b439bbf9507f7bed53d7c2c1a22e07a064e8","modified":1489723380880},{"_id":"public/css/app.css","hash":"46fce06ef740d38f5cb20fb45f340ca365e13dca","modified":1489723380903},{"_id":"public/js/app.js","hash":"8e00097211a064209ae0e9fb556920673f5b9a42","modified":1489723380904},{"_id":"public/images/banner-large.png","hash":"3e91a135ca4c446301995aedc998784e035d485a","modified":1489723380904},{"_id":"source/_posts/_images/.DS_Store","hash":"0c8db056f2f69870431fd926e04b92cb901b41f0","modified":1489723038000},{"_id":"source/_posts/_images/Xcode 创建自定义模板 (来源网络)/1693553-0bed79c964adb6dc.png","hash":"61048cbd4105d38d09fc92126cccde77feb76d0f","modified":1489722636000},{"_id":"source/_posts/_images/Xcode 创建自定义模板 (来源网络)/1693553-0ed0fdac87c08112.png","hash":"1f371f56e6b605b79d49fb96f6157716ebeb2e3f","modified":1489722821000},{"_id":"source/_posts/_images/Xcode 创建自定义模板 (来源网络)/1693553-98812f12b7414336.png","hash":"bce484757d70893de0eb65620cc5ae985ab84d81","modified":1489722708000},{"_id":"source/_posts/_images/Xcode 创建自定义模板 (来源网络)/1693553-d8e6c07058f379f0-1.png","hash":"33c3582f02ae35647f3de888734c7af914a6f731","modified":1489722838000},{"_id":"source/_images/Xcode /1693553-0bed79c964adb6dc.png","hash":"61048cbd4105d38d09fc92126cccde77feb76d0f","modified":1489722636000},{"_id":"source/_images/Xcode /1693553-0ed0fdac87c08112.png","hash":"1f371f56e6b605b79d49fb96f6157716ebeb2e3f","modified":1489722821000},{"_id":"source/_images/Xcode /1693553-98812f12b7414336.png","hash":"bce484757d70893de0eb65620cc5ae985ab84d81","modified":1489722708000},{"_id":"source/_images/Xcode /1693553-d8e6c07058f379f0-1.png","hash":"33c3582f02ae35647f3de888734c7af914a6f731","modified":1489722838000},{"_id":"source/_images/Xcode/1693553-0bed79c964adb6dc.png","hash":"61048cbd4105d38d09fc92126cccde77feb76d0f","modified":1489722636000},{"_id":"source/_images/Xcode/1693553-0ed0fdac87c08112.png","hash":"1f371f56e6b605b79d49fb96f6157716ebeb2e3f","modified":1489722821000},{"_id":"source/_images/Xcode/1693553-98812f12b7414336.png","hash":"bce484757d70893de0eb65620cc5ae985ab84d81","modified":1489722708000},{"_id":"source/_images/Xcode/1693553-d8e6c07058f379f0-1.png","hash":"33c3582f02ae35647f3de888734c7af914a6f731","modified":1489722838000},{"_id":"source/_images/1693553-0bed79c964adb6dc.png","hash":"61048cbd4105d38d09fc92126cccde77feb76d0f","modified":1489722636000},{"_id":"source/_images/1693553-0ed0fdac87c08112.png","hash":"1f371f56e6b605b79d49fb96f6157716ebeb2e3f","modified":1489722821000},{"_id":"source/_images/1693553-98812f12b7414336.png","hash":"bce484757d70893de0eb65620cc5ae985ab84d81","modified":1489722708000},{"_id":"source/_images/1693553-d8e6c07058f379f0-1.png","hash":"33c3582f02ae35647f3de888734c7af914a6f731","modified":1489722838000},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1489729247000},{"_id":"source/img/1693553-0bed79c964adb6dc.png","hash":"61048cbd4105d38d09fc92126cccde77feb76d0f","modified":1489722636000},{"_id":"source/img/1693553-0ed0fdac87c08112.png","hash":"1f371f56e6b605b79d49fb96f6157716ebeb2e3f","modified":1489722821000},{"_id":"source/img/1693553-98812f12b7414336.png","hash":"bce484757d70893de0eb65620cc5ae985ab84d81","modified":1489722708000},{"_id":"source/img/1693553-d8e6c07058f379f0-1.png","hash":"33c3582f02ae35647f3de888734c7af914a6f731","modified":1489722838000},{"_id":"public/img/1693553-0bed79c964adb6dc.png","hash":"61048cbd4105d38d09fc92126cccde77feb76d0f","modified":1489728508587},{"_id":"public/img/1693553-0ed0fdac87c08112.png","hash":"1f371f56e6b605b79d49fb96f6157716ebeb2e3f","modified":1489728508588},{"_id":"public/img/1693553-98812f12b7414336.png","hash":"bce484757d70893de0eb65620cc5ae985ab84d81","modified":1489728508589},{"_id":"public/img/1693553-d8e6c07058f379f0-1.png","hash":"33c3582f02ae35647f3de888734c7af914a6f731","modified":1489728508589},{"_id":"public/2017/03/21/IOS 开发经验总结(不定时更新)/index.html","hash":"ba006614f40572b441b283be5b55cc9b3816ec09","modified":1490078303569},{"_id":"source/_posts/获取iOS设备唯一标示UUID (转发).md","hash":"b1c16d1195453ad5f520d351cf62ef647a56a63b","modified":1492738669000},{"_id":"source/img/277755-72008ba008a56557.png","hash":"75f47cf2efed2b14a00f324d4cdfd5c1395c2453","modified":1492738358000},{"_id":"source/img/277755-e736892057d71333.png","hash":"c7871445c7bd44c802b1380b6c395039fab99461","modified":1492738377000},{"_id":"source/img/277755-807a54b6dcbeb347.png","hash":"2d848be6a986c09178c8d6458a027fae9c8344a9","modified":1492738142000},{"_id":"public/archives/2017/04/index.html","hash":"0b75da52106a81c0f013c3ecaddbf06981b27300","modified":1492738824105},{"_id":"public/2017/04/21/获取iOS设备唯一标示UUID (转发)/index.html","hash":"230fc20c46c8e78f7b93bd452cd85ad9fb883899","modified":1492738824105},{"_id":"public/img/277755-72008ba008a56557.png","hash":"75f47cf2efed2b14a00f324d4cdfd5c1395c2453","modified":1492738824108},{"_id":"public/img/277755-e736892057d71333.png","hash":"c7871445c7bd44c802b1380b6c395039fab99461","modified":1492738824108},{"_id":"public/img/277755-807a54b6dcbeb347.png","hash":"2d848be6a986c09178c8d6458a027fae9c8344a9","modified":1492738824117}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"IOS 开发经验总结(不定时更新)","date":"2017-03-21T06:00:00.000Z","_content":"\n1.使用Podfile管理Pods依赖库版本\n```\npod 'AFNetworking'      //不显式指定依赖库版本，表示每次都获取最新版本    \npod 'AFNetworking', '2.0'     //只使用2.0版本    \npod 'AFNetworking', '> 2.0'     //使用高于2.0的版本    \npod 'AFNetworking', '>= 2.0'     //使用大于或等于2.0的版本    \npod 'AFNetworking', '< 2.0'     //使用小于2.0的版本    \npod 'AFNetworking', '<= 2.0'     //使用小于或等于2.0的版本    \npod 'AFNetworking', '~> 0.1.2'     //使用大于等于0.1.2但小于0.2的版本    \npod 'AFNetworking', '~>0.1'     //使用大于等于0.1但小于1.0的版本    \npod 'AFNetworking', '~>0'     //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本  \n```\n \n### 2.使用系统原生 nabber backItem显示文字问题\neg: A,B两个VC, A navItem.Title = 首页,A push 到 B, B的backItem Title 返回显示 **首页**，这里想更改这个文字 ，在A界面设置navitem 的 BackItem title = 返回，再push ，的backItem Title 显示 **返回**；使用原生的backItem 必须先提前设置backItem title; \n`self.navigationItem.backBarButtonItem = [UIBarButtonItem alloc] initWithTitle:<#(nullable NSString *)#> style:<#(UIBarButtonItemStyle)#> target:<#(nullable id)#> action:<#(nullable SEL)#>`\n\n### 3.  设置 uibarbuttonitem image 时按钮变成蓝色\n\n*着色（Tint Color）是iOS7界面中的一个.设置UIImage的渲染模式：UIImage.renderingMode重大改变，你可以设置一个UIImage在渲染时是否使用当前视图的Tint Color。UIImage新增了一个只读属性：renderingMode，对应的还有一个新增方法：imageWithRenderingMode:，它使用UIImageRenderingMode枚举值来设置图片的renderingMode属性。该枚举中包含下列值：\n\nUIImageRenderingModeAutomatic   根据图片的使用环境和所处的绘图上下文自动调整渲染模式。  \nUIImageRenderingModeAlwaysOriginal    始终绘制图片原始状态，不使用Tint Color。  \nUIImageRenderingModeAlwaysTemplate    始终根据Tint Color绘制图片，忽略图片的颜色信息。  \n \nrenderingMode属性的默认值是UIImageRenderingModeAutomatic，即UIImage是否使用Tint Color取决于它显示的位置。其他情况可以看下面的图例*\n设置selectedImage 的 renderingMode 为UIImageRenderingModeAlwaysOriginal\nUIImage *selectedImage=[UIImage imageNamed: @\"btn_nav_share_lawyer\"];\n        selectedImage = [selectedImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];\n  创建baritem\n shareBarBtn = [[UIBarButtonItem alloc] initWithImage:selectedImage style:UIBarButtonItemStyleDone target:self action:@selector(shareAction)];\n","source":"_posts/IOS 开发经验总结(不定时更新).md","raw":"---\ntitle: IOS 开发经验总结(不定时更新)\ndate: 2017-03-21 14:00:00\ntags:\n---\n\n1.使用Podfile管理Pods依赖库版本\n```\npod 'AFNetworking'      //不显式指定依赖库版本，表示每次都获取最新版本    \npod 'AFNetworking', '2.0'     //只使用2.0版本    \npod 'AFNetworking', '> 2.0'     //使用高于2.0的版本    \npod 'AFNetworking', '>= 2.0'     //使用大于或等于2.0的版本    \npod 'AFNetworking', '< 2.0'     //使用小于2.0的版本    \npod 'AFNetworking', '<= 2.0'     //使用小于或等于2.0的版本    \npod 'AFNetworking', '~> 0.1.2'     //使用大于等于0.1.2但小于0.2的版本    \npod 'AFNetworking', '~>0.1'     //使用大于等于0.1但小于1.0的版本    \npod 'AFNetworking', '~>0'     //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本  \n```\n \n### 2.使用系统原生 nabber backItem显示文字问题\neg: A,B两个VC, A navItem.Title = 首页,A push 到 B, B的backItem Title 返回显示 **首页**，这里想更改这个文字 ，在A界面设置navitem 的 BackItem title = 返回，再push ，的backItem Title 显示 **返回**；使用原生的backItem 必须先提前设置backItem title; \n`self.navigationItem.backBarButtonItem = [UIBarButtonItem alloc] initWithTitle:<#(nullable NSString *)#> style:<#(UIBarButtonItemStyle)#> target:<#(nullable id)#> action:<#(nullable SEL)#>`\n\n### 3.  设置 uibarbuttonitem image 时按钮变成蓝色\n\n*着色（Tint Color）是iOS7界面中的一个.设置UIImage的渲染模式：UIImage.renderingMode重大改变，你可以设置一个UIImage在渲染时是否使用当前视图的Tint Color。UIImage新增了一个只读属性：renderingMode，对应的还有一个新增方法：imageWithRenderingMode:，它使用UIImageRenderingMode枚举值来设置图片的renderingMode属性。该枚举中包含下列值：\n\nUIImageRenderingModeAutomatic   根据图片的使用环境和所处的绘图上下文自动调整渲染模式。  \nUIImageRenderingModeAlwaysOriginal    始终绘制图片原始状态，不使用Tint Color。  \nUIImageRenderingModeAlwaysTemplate    始终根据Tint Color绘制图片，忽略图片的颜色信息。  \n \nrenderingMode属性的默认值是UIImageRenderingModeAutomatic，即UIImage是否使用Tint Color取决于它显示的位置。其他情况可以看下面的图例*\n设置selectedImage 的 renderingMode 为UIImageRenderingModeAlwaysOriginal\nUIImage *selectedImage=[UIImage imageNamed: @\"btn_nav_share_lawyer\"];\n        selectedImage = [selectedImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];\n  创建baritem\n shareBarBtn = [[UIBarButtonItem alloc] initWithImage:selectedImage style:UIBarButtonItemStyleDone target:self action:@selector(shareAction)];\n","slug":"IOS 开发经验总结(不定时更新)","published":1,"updated":"2017-03-21T06:38:16.000Z","_id":"cj0dau52600009z4t0haw8zpp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>1.使用Podfile管理Pods依赖库版本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;AFNetworking&apos;      //不显式指定依赖库版本，表示每次都获取最新版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;2.0&apos;     //只使用2.0版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;&gt; 2.0&apos;     //使用高于2.0的版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;&gt;= 2.0&apos;     //使用大于或等于2.0的版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;&lt; 2.0&apos;     //使用小于2.0的版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;&lt;= 2.0&apos;     //使用小于或等于2.0的版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;~&gt; 0.1.2&apos;     //使用大于等于0.1.2但小于0.2的版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;~&gt;0.1&apos;     //使用大于等于0.1但小于1.0的版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;~&gt;0&apos;     //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-使用系统原生-nabber-backItem显示文字问题\"><a href=\"#2-使用系统原生-nabber-backItem显示文字问题\" class=\"headerlink\" title=\"2.使用系统原生 nabber backItem显示文字问题\"></a>2.使用系统原生 nabber backItem显示文字问题</h3><p>eg: A,B两个VC, A navItem.Title = 首页,A push 到 B, B的backItem Title 返回显示 <strong>首页</strong>，这里想更改这个文字 ，在A界面设置navitem 的 BackItem title = 返回，再push ，的backItem Title 显示 <strong>返回</strong>；使用原生的backItem 必须先提前设置backItem title;<br><code>self.navigationItem.backBarButtonItem = [UIBarButtonItem alloc] initWithTitle:&lt;#(nullable NSString *)#&gt; style:&lt;#(UIBarButtonItemStyle)#&gt; target:&lt;#(nullable id)#&gt; action:&lt;#(nullable SEL)#&gt;</code></p>\n<h3 id=\"3-设置-uibarbuttonitem-image-时按钮变成蓝色\"><a href=\"#3-设置-uibarbuttonitem-image-时按钮变成蓝色\" class=\"headerlink\" title=\"3.  设置 uibarbuttonitem image 时按钮变成蓝色\"></a>3.  设置 uibarbuttonitem image 时按钮变成蓝色</h3><p>*着色（Tint Color）是iOS7界面中的一个.设置UIImage的渲染模式：UIImage.renderingMode重大改变，你可以设置一个UIImage在渲染时是否使用当前视图的Tint Color。UIImage新增了一个只读属性：renderingMode，对应的还有一个新增方法：imageWithRenderingMode:，它使用UIImageRenderingMode枚举值来设置图片的renderingMode属性。该枚举中包含下列值：</p>\n<p>UIImageRenderingModeAutomatic   根据图片的使用环境和所处的绘图上下文自动调整渲染模式。<br>UIImageRenderingModeAlwaysOriginal    始终绘制图片原始状态，不使用Tint Color。<br>UIImageRenderingModeAlwaysTemplate    始终根据Tint Color绘制图片，忽略图片的颜色信息。  </p>\n<p>renderingMode属性的默认值是UIImageRenderingModeAutomatic，即UIImage是否使用Tint Color取决于它显示的位置。其他情况可以看下面的图例<em><br>设置selectedImage 的 renderingMode 为UIImageRenderingModeAlwaysOriginal<br>UIImage </em>selectedImage=[UIImage imageNamed: @”btn_nav_share_lawyer”];<br>        selectedImage = [selectedImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];<br>  创建baritem<br> shareBarBtn = [[UIBarButtonItem alloc] initWithImage:selectedImage style:UIBarButtonItemStyleDone target:self action:@selector(shareAction)];</p>\n","excerpt":"","more":"<p>1.使用Podfile管理Pods依赖库版本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;AFNetworking&apos;      //不显式指定依赖库版本，表示每次都获取最新版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;2.0&apos;     //只使用2.0版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;&gt; 2.0&apos;     //使用高于2.0的版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;&gt;= 2.0&apos;     //使用大于或等于2.0的版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;&lt; 2.0&apos;     //使用小于2.0的版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;&lt;= 2.0&apos;     //使用小于或等于2.0的版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;~&gt; 0.1.2&apos;     //使用大于等于0.1.2但小于0.2的版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;~&gt;0.1&apos;     //使用大于等于0.1但小于1.0的版本    </div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;~&gt;0&apos;     //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-使用系统原生-nabber-backItem显示文字问题\"><a href=\"#2-使用系统原生-nabber-backItem显示文字问题\" class=\"headerlink\" title=\"2.使用系统原生 nabber backItem显示文字问题\"></a>2.使用系统原生 nabber backItem显示文字问题</h3><p>eg: A,B两个VC, A navItem.Title = 首页,A push 到 B, B的backItem Title 返回显示 <strong>首页</strong>，这里想更改这个文字 ，在A界面设置navitem 的 BackItem title = 返回，再push ，的backItem Title 显示 <strong>返回</strong>；使用原生的backItem 必须先提前设置backItem title;<br><code>self.navigationItem.backBarButtonItem = [UIBarButtonItem alloc] initWithTitle:&lt;#(nullable NSString *)#&gt; style:&lt;#(UIBarButtonItemStyle)#&gt; target:&lt;#(nullable id)#&gt; action:&lt;#(nullable SEL)#&gt;</code></p>\n<h3 id=\"3-设置-uibarbuttonitem-image-时按钮变成蓝色\"><a href=\"#3-设置-uibarbuttonitem-image-时按钮变成蓝色\" class=\"headerlink\" title=\"3.  设置 uibarbuttonitem image 时按钮变成蓝色\"></a>3.  设置 uibarbuttonitem image 时按钮变成蓝色</h3><p>*着色（Tint Color）是iOS7界面中的一个.设置UIImage的渲染模式：UIImage.renderingMode重大改变，你可以设置一个UIImage在渲染时是否使用当前视图的Tint Color。UIImage新增了一个只读属性：renderingMode，对应的还有一个新增方法：imageWithRenderingMode:，它使用UIImageRenderingMode枚举值来设置图片的renderingMode属性。该枚举中包含下列值：</p>\n<p>UIImageRenderingModeAutomatic   根据图片的使用环境和所处的绘图上下文自动调整渲染模式。<br>UIImageRenderingModeAlwaysOriginal    始终绘制图片原始状态，不使用Tint Color。<br>UIImageRenderingModeAlwaysTemplate    始终根据Tint Color绘制图片，忽略图片的颜色信息。  </p>\n<p>renderingMode属性的默认值是UIImageRenderingModeAutomatic，即UIImage是否使用Tint Color取决于它显示的位置。其他情况可以看下面的图例<em><br>设置selectedImage 的 renderingMode 为UIImageRenderingModeAlwaysOriginal<br>UIImage </em>selectedImage=[UIImage imageNamed: @”btn_nav_share_lawyer”];<br>        selectedImage = [selectedImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];<br>  创建baritem<br> shareBarBtn = [[UIBarButtonItem alloc] initWithImage:selectedImage style:UIBarButtonItemStyleDone target:self action:@selector(shareAction)];</p>\n"},{"title":"IOS面试题(初级)","date":"2017-03-03T06:40:15.000Z","_content":"**近日身边的朋友都在找工作，于是我在网上找了一些面试题目。(题目来源于网络)**\n1. Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?\n2.  #import 跟#include 又什么区别，@class呢, #import<> 跟 #import””又什么区别?\n3. 属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用?\n4. 写一个setter方法用于完成@property (nonatomic,retain)NSString *name,写一个setter方法用于完成@property(nonatomic，copy)NSString *name\n5. 对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?\n6. 常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int\n7. id 声明的对象有什么特性?\n8. Objective-C如何对内存管理的,说说你的看法和解决方法?\n9. 内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露?\n10. 如何对iOS设备进行性能测试?\n11. Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?\n12. MVC设计模式是什么？ 你还熟悉什么设计模式？\n13. 浅复制和深复制的区别?\n14. 类别的作用?继承和类别在实现中有何区别?\n15. 类别和类扩展的区别。\n16. 什么是KVO和KVC?\n17. 代理的作用?\n18. oc中可修改和不可以修改类型。\n19. 我们说的oc是动态运行时语言是什么意思?\n20. 通知和协议的不同之处?\n21. 什么是推送消息?\n22. 关于多态性\n23. 对于单例的理解\n24. frame和bounds有什么不同?\n25. 方法和选择器有何不同?\n26. OC的垃圾回收机制?\n27. NSOperation queue?\n28. 什么是延迟加载?\n29. 在iPhone应用中如何保存数据?\n30. 什么是谓词?\n31. iOS 中的多线程\n32. 谈谈Object-C的内存管理方式及过程？\n33. Object-C有多继承吗？没有的话用什么代替？cocoa 中所有的类都是NSObject 的子类\n\n\n\n","source":"_posts/IOS面试题(初级).md","raw":"---\ntitle: IOS面试题(初级)\ndate: 2017-03-03 14:40:15\ntags:\n---\n**近日身边的朋友都在找工作，于是我在网上找了一些面试题目。(题目来源于网络)**\n1. Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?\n2.  #import 跟#include 又什么区别，@class呢, #import<> 跟 #import””又什么区别?\n3. 属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用?\n4. 写一个setter方法用于完成@property (nonatomic,retain)NSString *name,写一个setter方法用于完成@property(nonatomic，copy)NSString *name\n5. 对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?\n6. 常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int\n7. id 声明的对象有什么特性?\n8. Objective-C如何对内存管理的,说说你的看法和解决方法?\n9. 内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露?\n10. 如何对iOS设备进行性能测试?\n11. Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?\n12. MVC设计模式是什么？ 你还熟悉什么设计模式？\n13. 浅复制和深复制的区别?\n14. 类别的作用?继承和类别在实现中有何区别?\n15. 类别和类扩展的区别。\n16. 什么是KVO和KVC?\n17. 代理的作用?\n18. oc中可修改和不可以修改类型。\n19. 我们说的oc是动态运行时语言是什么意思?\n20. 通知和协议的不同之处?\n21. 什么是推送消息?\n22. 关于多态性\n23. 对于单例的理解\n24. frame和bounds有什么不同?\n25. 方法和选择器有何不同?\n26. OC的垃圾回收机制?\n27. NSOperation queue?\n28. 什么是延迟加载?\n29. 在iPhone应用中如何保存数据?\n30. 什么是谓词?\n31. iOS 中的多线程\n32. 谈谈Object-C的内存管理方式及过程？\n33. Object-C有多继承吗？没有的话用什么代替？cocoa 中所有的类都是NSObject 的子类\n\n\n\n","slug":"IOS面试题(初级)","published":1,"updated":"2017-03-03T02:03:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dau52d00019z4te51kzu0n","content":"<p><strong>近日身边的朋友都在找工作，于是我在网上找了一些面试题目。(题目来源于网络)</strong></p>\n<ol>\n<li>Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?</li>\n<li>#import 跟#include 又什么区别，@class呢, #import&lt;&gt; 跟 #import””又什么区别?</li>\n<li>属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用?</li>\n<li>写一个setter方法用于完成@property (nonatomic,retain)NSString <em>name,写一个setter方法用于完成@property(nonatomic，copy)NSString </em>name</li>\n<li>对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?</li>\n<li>常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int</li>\n<li>id 声明的对象有什么特性?</li>\n<li>Objective-C如何对内存管理的,说说你的看法和解决方法?</li>\n<li>内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露?</li>\n<li>如何对iOS设备进行性能测试?</li>\n<li>Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?</li>\n<li>MVC设计模式是什么？ 你还熟悉什么设计模式？</li>\n<li>浅复制和深复制的区别?</li>\n<li>类别的作用?继承和类别在实现中有何区别?</li>\n<li>类别和类扩展的区别。</li>\n<li>什么是KVO和KVC?</li>\n<li>代理的作用?</li>\n<li>oc中可修改和不可以修改类型。</li>\n<li>我们说的oc是动态运行时语言是什么意思?</li>\n<li>通知和协议的不同之处?</li>\n<li>什么是推送消息?</li>\n<li>关于多态性</li>\n<li>对于单例的理解</li>\n<li>frame和bounds有什么不同?</li>\n<li>方法和选择器有何不同?</li>\n<li>OC的垃圾回收机制?</li>\n<li>NSOperation queue?</li>\n<li>什么是延迟加载?</li>\n<li>在iPhone应用中如何保存数据?</li>\n<li>什么是谓词?</li>\n<li>iOS 中的多线程</li>\n<li>谈谈Object-C的内存管理方式及过程？</li>\n<li>Object-C有多继承吗？没有的话用什么代替？cocoa 中所有的类都是NSObject 的子类</li>\n</ol>\n","excerpt":"","more":"<p><strong>近日身边的朋友都在找工作，于是我在网上找了一些面试题目。(题目来源于网络)</strong></p>\n<ol>\n<li>Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?</li>\n<li>#import 跟#include 又什么区别，@class呢, #import&lt;&gt; 跟 #import””又什么区别?</li>\n<li>属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用?</li>\n<li>写一个setter方法用于完成@property (nonatomic,retain)NSString <em>name,写一个setter方法用于完成@property(nonatomic，copy)NSString </em>name</li>\n<li>对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?</li>\n<li>常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int</li>\n<li>id 声明的对象有什么特性?</li>\n<li>Objective-C如何对内存管理的,说说你的看法和解决方法?</li>\n<li>内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露?</li>\n<li>如何对iOS设备进行性能测试?</li>\n<li>Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?</li>\n<li>MVC设计模式是什么？ 你还熟悉什么设计模式？</li>\n<li>浅复制和深复制的区别?</li>\n<li>类别的作用?继承和类别在实现中有何区别?</li>\n<li>类别和类扩展的区别。</li>\n<li>什么是KVO和KVC?</li>\n<li>代理的作用?</li>\n<li>oc中可修改和不可以修改类型。</li>\n<li>我们说的oc是动态运行时语言是什么意思?</li>\n<li>通知和协议的不同之处?</li>\n<li>什么是推送消息?</li>\n<li>关于多态性</li>\n<li>对于单例的理解</li>\n<li>frame和bounds有什么不同?</li>\n<li>方法和选择器有何不同?</li>\n<li>OC的垃圾回收机制?</li>\n<li>NSOperation queue?</li>\n<li>什么是延迟加载?</li>\n<li>在iPhone应用中如何保存数据?</li>\n<li>什么是谓词?</li>\n<li>iOS 中的多线程</li>\n<li>谈谈Object-C的内存管理方式及过程？</li>\n<li>Object-C有多继承吗？没有的话用什么代替？cocoa 中所有的类都是NSObject 的子类</li>\n</ol>\n"},{"title":"Xcode 创建自定义模板 (来源网络)","date":"2017-03-17T04:00:00.000Z","_content":"\n### 1 模板方案路径\n系统模板的路径（Xcode7）_Applications_Xcode.app_Contents_Developer_Library_Xcode_Templates_File Templates在这个目录下；\n![](/img/1693553-98812f12b7414336.png)\n其中的Core Data、Other、Resource、Source和User Interface对应着\n![](/img/1693553-0bed79c964adb6dc.png)\n### BaseVC.xctemplate介绍\n\n假设已经将BaseVC.xctemplate放入了Source文件夹中，查看BaseVC.xctemplate中有\n（1）BaseViewControllerObjective-C 文件夹\n用来创建.h 和 .m文件。 其中文件夹的命名规范是[name]+Objective-C. 如果是创建swift修改为swift。\n（2）BaseViewControllerXibObjective-C文件夹\n用来创建.h，.m和.xib文件。其中文件夹的命名规范是[name]+XibObjective-C. swift类似。\n（3）TemplateIcon图片\n图片是用来显示在New File的菜单上的。任意放一个自己喜欢的图片，像素138*138即可。\n（4）TemplateInfo.plist\n配置文件。下面单独讲讲。\n\n###  3.___FILEBASENAME___.h\n内容为\n\n\n  ___FILENAME___\n  ___PROJECTNAME___\n\n  Created by ___FULLUSERNAME___ on ___DATE___.\n___COPYRIGHT___\n\n\n#import \"___VARIABLE_cocoaTouchSubclass___.h\"\n\n@interface ___FILEBASENAMEASIDENTIFIER___ : ___VARIABLE_cocoaTouchSubclass___\n\n@end\n里面的参数在生成h文件时，系统会替换了输入的文件名。具体都是什么含义，大家可以自行Google了。\n\n### 4. ___FILEBASENAME___.m\n\n内容为\n\n\n  ___FILENAME___\n  ___PROJECTNAME___\n\n  Created by ___FULLUSERNAME___ on ___DATE___.\n___COPYRIGHT___\n\n#import \"___FILEBASENAME___.h\"\n Controllers\n Model\n Views\n\n#define <#macro#> <#value#>\n\n\n@interface ___FILEBASENAMEASIDENTIFIER___ ()\n\n@property (nonatomic, strong) <#type#> *<#name#>\n@end\n@implementation ___FILEBASENAMEASIDENTIFIER___\n\n#pragma mark - View Controller LifeCyle\n\n- [ ] (instancetype)initWithCoder:(NSCoder *)coder\n{\n    self = [super initWithCoder:coder];\n    if (self) {\n    }\n    return self;\n}   \n- [ ] (void)viewDidLoad\n{\n    [super viewDidLoad];\n\n    [self initialNavigationBar];\n}\n- [ ] (void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n}\n- [ ] (void)viewWillDisappear:(BOOL)animated\n{\n    [super viewWillDisappear:animated];\n}\n\n- [ ] (void)didReceiveMemoryWarning\n{\n    [super didReceiveMemoryWarning];\n\n    [[SDImageCache sharedImageCache] setValue:nil forKey:@\"memCache\"];\n}\n\n- [ ] (void)dealloc\n{\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n}\n#pragma mark - Override\n\n#pragma mark - Initial Methods\n\n- [ ] (void)initialNavigationBar\n{\n    self.navigationItem.title = <#title#>;\n}\n\n#pragma mark - Target Methods\n\n#pragma mark - Notification Methods\n\n#pragma mark - KVO Methods\n\n#pragma mark - UITableViewDelegate, UITableViewDataSource\n\n#pragma mark - Privater Methods\n\n#pragma mark - Setter Getter Methods\n\n@end\n按编程规范编写的，大家可以自行修改，New File后将自动生成你修改的内容。\n### 5. TemplateInfo.plist\n![](/img/1693553-0ed0fdac87c08112.png)\nSortOrder 这个是排序的值，可以设置在界面中的摆放位置\nOptions中的Item0，Item1，Item2，Item3 对应了\n![](/img/1693553-d8e6c07058f379f0-1.png)\n自定义的BaseViewController的类，当然可以使用系统或自己定义。\nBaseViewController的后缀。选择后，自动在Class后面添加ViewController的后缀。\n是否生成Xib文件，默认是ture。当选择了BaseViewController时，可以进行checkout，不然不可选，不生成Xib文件。\n","source":"_posts/Xcode 创建自定义模板 (网络).md","raw":"\n---\ntitle: Xcode 创建自定义模板 (来源网络)\ndate: 2017-03-17 12:00:00\ntags:\n---\n\n### 1 模板方案路径\n系统模板的路径（Xcode7）_Applications_Xcode.app_Contents_Developer_Library_Xcode_Templates_File Templates在这个目录下；\n![](/img/1693553-98812f12b7414336.png)\n其中的Core Data、Other、Resource、Source和User Interface对应着\n![](/img/1693553-0bed79c964adb6dc.png)\n### BaseVC.xctemplate介绍\n\n假设已经将BaseVC.xctemplate放入了Source文件夹中，查看BaseVC.xctemplate中有\n（1）BaseViewControllerObjective-C 文件夹\n用来创建.h 和 .m文件。 其中文件夹的命名规范是[name]+Objective-C. 如果是创建swift修改为swift。\n（2）BaseViewControllerXibObjective-C文件夹\n用来创建.h，.m和.xib文件。其中文件夹的命名规范是[name]+XibObjective-C. swift类似。\n（3）TemplateIcon图片\n图片是用来显示在New File的菜单上的。任意放一个自己喜欢的图片，像素138*138即可。\n（4）TemplateInfo.plist\n配置文件。下面单独讲讲。\n\n###  3.___FILEBASENAME___.h\n内容为\n\n\n  ___FILENAME___\n  ___PROJECTNAME___\n\n  Created by ___FULLUSERNAME___ on ___DATE___.\n___COPYRIGHT___\n\n\n#import \"___VARIABLE_cocoaTouchSubclass___.h\"\n\n@interface ___FILEBASENAMEASIDENTIFIER___ : ___VARIABLE_cocoaTouchSubclass___\n\n@end\n里面的参数在生成h文件时，系统会替换了输入的文件名。具体都是什么含义，大家可以自行Google了。\n\n### 4. ___FILEBASENAME___.m\n\n内容为\n\n\n  ___FILENAME___\n  ___PROJECTNAME___\n\n  Created by ___FULLUSERNAME___ on ___DATE___.\n___COPYRIGHT___\n\n#import \"___FILEBASENAME___.h\"\n Controllers\n Model\n Views\n\n#define <#macro#> <#value#>\n\n\n@interface ___FILEBASENAMEASIDENTIFIER___ ()\n\n@property (nonatomic, strong) <#type#> *<#name#>\n@end\n@implementation ___FILEBASENAMEASIDENTIFIER___\n\n#pragma mark - View Controller LifeCyle\n\n- [ ] (instancetype)initWithCoder:(NSCoder *)coder\n{\n    self = [super initWithCoder:coder];\n    if (self) {\n    }\n    return self;\n}   \n- [ ] (void)viewDidLoad\n{\n    [super viewDidLoad];\n\n    [self initialNavigationBar];\n}\n- [ ] (void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n}\n- [ ] (void)viewWillDisappear:(BOOL)animated\n{\n    [super viewWillDisappear:animated];\n}\n\n- [ ] (void)didReceiveMemoryWarning\n{\n    [super didReceiveMemoryWarning];\n\n    [[SDImageCache sharedImageCache] setValue:nil forKey:@\"memCache\"];\n}\n\n- [ ] (void)dealloc\n{\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n}\n#pragma mark - Override\n\n#pragma mark - Initial Methods\n\n- [ ] (void)initialNavigationBar\n{\n    self.navigationItem.title = <#title#>;\n}\n\n#pragma mark - Target Methods\n\n#pragma mark - Notification Methods\n\n#pragma mark - KVO Methods\n\n#pragma mark - UITableViewDelegate, UITableViewDataSource\n\n#pragma mark - Privater Methods\n\n#pragma mark - Setter Getter Methods\n\n@end\n按编程规范编写的，大家可以自行修改，New File后将自动生成你修改的内容。\n### 5. TemplateInfo.plist\n![](/img/1693553-0ed0fdac87c08112.png)\nSortOrder 这个是排序的值，可以设置在界面中的摆放位置\nOptions中的Item0，Item1，Item2，Item3 对应了\n![](/img/1693553-d8e6c07058f379f0-1.png)\n自定义的BaseViewController的类，当然可以使用系统或自己定义。\nBaseViewController的后缀。选择后，自动在Class后面添加ViewController的后缀。\n是否生成Xib文件，默认是ture。当选择了BaseViewController时，可以进行checkout，不然不可选，不生成Xib文件。\n","slug":"Xcode 创建自定义模板 (网络)","published":1,"updated":"2017-03-17T05:41:33.000Z","_id":"cj0dau52g00029z4tpnnpcjek","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-模板方案路径\"><a href=\"#1-模板方案路径\" class=\"headerlink\" title=\"1 模板方案路径\"></a>1 模板方案路径</h3><p>系统模板的路径（Xcode7）_Applications_Xcode.app_Contents_Developer_Library_Xcode_Templates_File Templates在这个目录下；<br><img src=\"/img/1693553-98812f12b7414336.png\" alt=\"\"><br>其中的Core Data、Other、Resource、Source和User Interface对应着<br><img src=\"/img/1693553-0bed79c964adb6dc.png\" alt=\"\"></p>\n<h3 id=\"BaseVC-xctemplate介绍\"><a href=\"#BaseVC-xctemplate介绍\" class=\"headerlink\" title=\"BaseVC.xctemplate介绍\"></a>BaseVC.xctemplate介绍</h3><p>假设已经将BaseVC.xctemplate放入了Source文件夹中，查看BaseVC.xctemplate中有<br>（1）BaseViewControllerObjective-C 文件夹<br>用来创建.h 和 .m文件。 其中文件夹的命名规范是[name]+Objective-C. 如果是创建swift修改为swift。<br>（2）BaseViewControllerXibObjective-C文件夹<br>用来创建.h，.m和.xib文件。其中文件夹的命名规范是[name]+XibObjective-C. swift类似。<br>（3）TemplateIcon图片<br>图片是用来显示在New File的菜单上的。任意放一个自己喜欢的图片，像素138*138即可。<br>（4）TemplateInfo.plist<br>配置文件。下面单独讲讲。</p>\n<h3 id=\"3-FILEBASENAME-h\"><a href=\"#3-FILEBASENAME-h\" class=\"headerlink\" title=\"3.FILEBASENAME.h\"></a>3.<strong><em>FILEBASENAME</em></strong>.h</h3><p>内容为</p>\n<p>  <strong><em>FILENAME</em></strong><br>  <strong><em>PROJECTNAME</em></strong></p>\n<p>  Created by <strong><em>FULLUSERNAME</em></strong> on <strong><em>DATE</em></strong>.<br><strong><em>COPYRIGHT</em></strong></p>\n<p>#import “<strong>_VARIABLE<em>cocoaTouchSubclass</em></strong>.h”</p>\n<p>@interface <strong><em>FILEBASENAMEASIDENTIFIER</em></strong> : <strong>_VARIABLE<em>cocoaTouchSubclass</em></strong></p>\n<p>@end<br>里面的参数在生成h文件时，系统会替换了输入的文件名。具体都是什么含义，大家可以自行Google了。</p>\n<h3 id=\"4-FILEBASENAME-m\"><a href=\"#4-FILEBASENAME-m\" class=\"headerlink\" title=\"4. FILEBASENAME.m\"></a>4. <strong><em>FILEBASENAME</em></strong>.m</h3><p>内容为</p>\n<p>  <strong><em>FILENAME</em></strong><br>  <strong><em>PROJECTNAME</em></strong></p>\n<p>  Created by <strong><em>FULLUSERNAME</em></strong> on <strong><em>DATE</em></strong>.<br><strong><em>COPYRIGHT</em></strong></p>\n<p>#import “<strong><em>FILEBASENAME</em></strong>.h”<br> Controllers<br> Model<br> Views</p>\n<p>#define &lt;#macro#&gt; &lt;#value#&gt;</p>\n<p>@interface <strong><em>FILEBASENAMEASIDENTIFIER</em></strong> ()</p>\n<p>@property (nonatomic, strong) &lt;#type#&gt; *&lt;#name#&gt;<br>@end<br>@implementation <strong><em>FILEBASENAMEASIDENTIFIER</em></strong></p>\n<p>#pragma mark - View Controller LifeCyle</p>\n<ul>\n<li>[ ] (instancetype)initWithCoder:(NSCoder *)coder<br>{<br>  self = [super initWithCoder:coder];<br>  if (self) {<br>  }<br>  return self;<br>}   </li>\n<li><p>[ ] (void)viewDidLoad<br>{<br>  [super viewDidLoad];</p>\n<p>  [self initialNavigationBar];<br>}</p>\n</li>\n<li>[ ] (void)viewDidAppear:(BOOL)animated<br>{<br>  [super viewDidAppear:animated];<br>}</li>\n<li><p>[ ] (void)viewWillDisappear:(BOOL)animated<br>{<br>  [super viewWillDisappear:animated];<br>}</p>\n</li>\n<li><p>[ ] (void)didReceiveMemoryWarning<br>{<br>  [super didReceiveMemoryWarning];</p>\n<p>  [[SDImageCache sharedImageCache] setValue:nil forKey:@”memCache”];<br>}</p>\n</li>\n<li><p>[ ] (void)dealloc<br>{<br>  [[NSNotificationCenter defaultCenter] removeObserver:self];<br>}<br>#pragma mark - Override</p>\n</li>\n</ul>\n<p>#pragma mark - Initial Methods</p>\n<ul>\n<li>[ ] (void)initialNavigationBar<br>{<br>  self.navigationItem.title = &lt;#title#&gt;;<br>}</li>\n</ul>\n<p>#pragma mark - Target Methods</p>\n<p>#pragma mark - Notification Methods</p>\n<p>#pragma mark - KVO Methods</p>\n<p>#pragma mark - UITableViewDelegate, UITableViewDataSource</p>\n<p>#pragma mark - Privater Methods</p>\n<p>#pragma mark - Setter Getter Methods</p>\n<p>@end<br>按编程规范编写的，大家可以自行修改，New File后将自动生成你修改的内容。</p>\n<h3 id=\"5-TemplateInfo-plist\"><a href=\"#5-TemplateInfo-plist\" class=\"headerlink\" title=\"5. TemplateInfo.plist\"></a>5. TemplateInfo.plist</h3><p><img src=\"/img/1693553-0ed0fdac87c08112.png\" alt=\"\"><br>SortOrder 这个是排序的值，可以设置在界面中的摆放位置<br>Options中的Item0，Item1，Item2，Item3 对应了<br><img src=\"/img/1693553-d8e6c07058f379f0-1.png\" alt=\"\"><br>自定义的BaseViewController的类，当然可以使用系统或自己定义。<br>BaseViewController的后缀。选择后，自动在Class后面添加ViewController的后缀。<br>是否生成Xib文件，默认是ture。当选择了BaseViewController时，可以进行checkout，不然不可选，不生成Xib文件。</p>\n","excerpt":"","more":"<h3 id=\"1-模板方案路径\"><a href=\"#1-模板方案路径\" class=\"headerlink\" title=\"1 模板方案路径\"></a>1 模板方案路径</h3><p>系统模板的路径（Xcode7）_Applications_Xcode.app_Contents_Developer_Library_Xcode_Templates_File Templates在这个目录下；<br><img src=\"/img/1693553-98812f12b7414336.png\" alt=\"\"><br>其中的Core Data、Other、Resource、Source和User Interface对应着<br><img src=\"/img/1693553-0bed79c964adb6dc.png\" alt=\"\"></p>\n<h3 id=\"BaseVC-xctemplate介绍\"><a href=\"#BaseVC-xctemplate介绍\" class=\"headerlink\" title=\"BaseVC.xctemplate介绍\"></a>BaseVC.xctemplate介绍</h3><p>假设已经将BaseVC.xctemplate放入了Source文件夹中，查看BaseVC.xctemplate中有<br>（1）BaseViewControllerObjective-C 文件夹<br>用来创建.h 和 .m文件。 其中文件夹的命名规范是[name]+Objective-C. 如果是创建swift修改为swift。<br>（2）BaseViewControllerXibObjective-C文件夹<br>用来创建.h，.m和.xib文件。其中文件夹的命名规范是[name]+XibObjective-C. swift类似。<br>（3）TemplateIcon图片<br>图片是用来显示在New File的菜单上的。任意放一个自己喜欢的图片，像素138*138即可。<br>（4）TemplateInfo.plist<br>配置文件。下面单独讲讲。</p>\n<h3 id=\"3-FILEBASENAME-h\"><a href=\"#3-FILEBASENAME-h\" class=\"headerlink\" title=\"3.FILEBASENAME.h\"></a>3.<strong><em>FILEBASENAME</em></strong>.h</h3><p>内容为</p>\n<p>  <strong><em>FILENAME</em></strong><br>  <strong><em>PROJECTNAME</em></strong></p>\n<p>  Created by <strong><em>FULLUSERNAME</em></strong> on <strong><em>DATE</em></strong>.<br><strong><em>COPYRIGHT</em></strong></p>\n<p>#import “<strong>_VARIABLE<em>cocoaTouchSubclass</em></strong>.h”</p>\n<p>@interface <strong><em>FILEBASENAMEASIDENTIFIER</em></strong> : <strong>_VARIABLE<em>cocoaTouchSubclass</em></strong></p>\n<p>@end<br>里面的参数在生成h文件时，系统会替换了输入的文件名。具体都是什么含义，大家可以自行Google了。</p>\n<h3 id=\"4-FILEBASENAME-m\"><a href=\"#4-FILEBASENAME-m\" class=\"headerlink\" title=\"4. FILEBASENAME.m\"></a>4. <strong><em>FILEBASENAME</em></strong>.m</h3><p>内容为</p>\n<p>  <strong><em>FILENAME</em></strong><br>  <strong><em>PROJECTNAME</em></strong></p>\n<p>  Created by <strong><em>FULLUSERNAME</em></strong> on <strong><em>DATE</em></strong>.<br><strong><em>COPYRIGHT</em></strong></p>\n<p>#import “<strong><em>FILEBASENAME</em></strong>.h”<br> Controllers<br> Model<br> Views</p>\n<p>#define &lt;#macro#&gt; &lt;#value#&gt;</p>\n<p>@interface <strong><em>FILEBASENAMEASIDENTIFIER</em></strong> ()</p>\n<p>@property (nonatomic, strong) &lt;#type#&gt; *&lt;#name#&gt;<br>@end<br>@implementation <strong><em>FILEBASENAMEASIDENTIFIER</em></strong></p>\n<p>#pragma mark - View Controller LifeCyle</p>\n<ul>\n<li>[ ] (instancetype)initWithCoder:(NSCoder *)coder<br>{<br>  self = [super initWithCoder:coder];<br>  if (self) {<br>  }<br>  return self;<br>}   </li>\n<li><p>[ ] (void)viewDidLoad<br>{<br>  [super viewDidLoad];</p>\n<p>  [self initialNavigationBar];<br>}</p>\n</li>\n<li>[ ] (void)viewDidAppear:(BOOL)animated<br>{<br>  [super viewDidAppear:animated];<br>}</li>\n<li><p>[ ] (void)viewWillDisappear:(BOOL)animated<br>{<br>  [super viewWillDisappear:animated];<br>}</p>\n</li>\n<li><p>[ ] (void)didReceiveMemoryWarning<br>{<br>  [super didReceiveMemoryWarning];</p>\n<p>  [[SDImageCache sharedImageCache] setValue:nil forKey:@”memCache”];<br>}</p>\n</li>\n<li><p>[ ] (void)dealloc<br>{<br>  [[NSNotificationCenter defaultCenter] removeObserver:self];<br>}<br>#pragma mark - Override</p>\n</li>\n</ul>\n<p>#pragma mark - Initial Methods</p>\n<ul>\n<li>[ ] (void)initialNavigationBar<br>{<br>  self.navigationItem.title = &lt;#title#&gt;;<br>}</li>\n</ul>\n<p>#pragma mark - Target Methods</p>\n<p>#pragma mark - Notification Methods</p>\n<p>#pragma mark - KVO Methods</p>\n<p>#pragma mark - UITableViewDelegate, UITableViewDataSource</p>\n<p>#pragma mark - Privater Methods</p>\n<p>#pragma mark - Setter Getter Methods</p>\n<p>@end<br>按编程规范编写的，大家可以自行修改，New File后将自动生成你修改的内容。</p>\n<h3 id=\"5-TemplateInfo-plist\"><a href=\"#5-TemplateInfo-plist\" class=\"headerlink\" title=\"5. TemplateInfo.plist\"></a>5. TemplateInfo.plist</h3><p><img src=\"/img/1693553-0ed0fdac87c08112.png\" alt=\"\"><br>SortOrder 这个是排序的值，可以设置在界面中的摆放位置<br>Options中的Item0，Item1，Item2，Item3 对应了<br><img src=\"/img/1693553-d8e6c07058f379f0-1.png\" alt=\"\"><br>自定义的BaseViewController的类，当然可以使用系统或自己定义。<br>BaseViewController的后缀。选择后，自动在Class后面添加ViewController的后缀。<br>是否生成Xib文件，默认是ture。当选择了BaseViewController时，可以进行checkout，不然不可选，不生成Xib文件。</p>\n"},{"title":"使用SourceTree&Github 碰到的问题","date":"2017-03-02T06:40:15.000Z","_content":"### 使用github 创建一个空白仓库时，使用sourcetree克隆下来的分支里面找不到master分支，错误提示：fatal: Not a valid object name: 'master'\n*解决方案 :*\n\t1. `git init`  初始化这个仓库\n\t2. `git --bare init`  清空这个仓库\n这时打开SourceTree，**未暂存文件**里面会出来多个文件，提交这些文件后，master 就正常显示了。\n**注：不知道是不是只有我碰到这类问题**\n","source":"_posts/使用SourceTree&Github 碰到的问题.md","raw":"---\ntitle: 使用SourceTree&Github 碰到的问题\ndate: 2017-03-02 14:40:15\ntags:\n---\n### 使用github 创建一个空白仓库时，使用sourcetree克隆下来的分支里面找不到master分支，错误提示：fatal: Not a valid object name: 'master'\n*解决方案 :*\n\t1. `git init`  初始化这个仓库\n\t2. `git --bare init`  清空这个仓库\n这时打开SourceTree，**未暂存文件**里面会出来多个文件，提交这些文件后，master 就正常显示了。\n**注：不知道是不是只有我碰到这类问题**\n","slug":"使用SourceTree&Github 碰到的问题","published":1,"updated":"2017-03-02T09:44:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dau52i00039z4tcqltlb8h","content":"<h3 id=\"使用github-创建一个空白仓库时，使用sourcetree克隆下来的分支里面找不到master分支，错误提示：fatal-Not-a-valid-object-name-‘master’\"><a href=\"#使用github-创建一个空白仓库时，使用sourcetree克隆下来的分支里面找不到master分支，错误提示：fatal-Not-a-valid-object-name-‘master’\" class=\"headerlink\" title=\"使用github 创建一个空白仓库时，使用sourcetree克隆下来的分支里面找不到master分支，错误提示：fatal: Not a valid object name: ‘master’\"></a>使用github 创建一个空白仓库时，使用sourcetree克隆下来的分支里面找不到master分支，错误提示：fatal: Not a valid object name: ‘master’</h3><p><em>解决方案 :</em></p>\n<pre><code>1. `git init`  初始化这个仓库\n2. `git --bare init`  清空这个仓库\n</code></pre><p>这时打开SourceTree，<strong>未暂存文件</strong>里面会出来多个文件，提交这些文件后，master 就正常显示了。<br><strong>注：不知道是不是只有我碰到这类问题</strong></p>\n","excerpt":"","more":"<h3 id=\"使用github-创建一个空白仓库时，使用sourcetree克隆下来的分支里面找不到master分支，错误提示：fatal-Not-a-valid-object-name-‘master’\"><a href=\"#使用github-创建一个空白仓库时，使用sourcetree克隆下来的分支里面找不到master分支，错误提示：fatal-Not-a-valid-object-name-‘master’\" class=\"headerlink\" title=\"使用github 创建一个空白仓库时，使用sourcetree克隆下来的分支里面找不到master分支，错误提示：fatal: Not a valid object name: ‘master’\"></a>使用github 创建一个空白仓库时，使用sourcetree克隆下来的分支里面找不到master分支，错误提示：fatal: Not a valid object name: ‘master’</h3><p><em>解决方案 :</em></p>\n<pre><code>1. `git init`  初始化这个仓库\n2. `git --bare init`  清空这个仓库\n</code></pre><p>这时打开SourceTree，<strong>未暂存文件</strong>里面会出来多个文件，提交这些文件后，master 就正常显示了。<br><strong>注：不知道是不是只有我碰到这类问题</strong></p>\n"},{"title":"获取iOS设备唯一标示UUID (转发来源简书)","date":"2017-04-21T01:30:00.000Z","_content":"\n在开发过程中，我们经常会被要求获取每个设备的唯一标示，以便后台做相应的处理。我们来看看有哪些方法来获取设备的唯一标示，然后再分析下这些方法的利弊。\n\n具体可以分为如下几种：\n\n1. UDID\n2. IDFA\n3. IDFV\n4. MAC\n5. keychain\n- - - -\n下面我们来具体分析下每种获取方法的利弊\n### 1、UDID\n\n什么是UDID\n\nUDID 「Unique Device Identifier Description」是由子母和数字组成的40个字符串的序号，用来区别每一个唯一的iOS设备，包括 iPhones, iPads, 以及 iPod touches，这些编码看起来是随机的，实际上是跟硬件设备特点相联系的，另外你可以到iTunes，pp助手或itools等软件查看你的udid（设备标识）\n\nUDID是用来干什么的？\n\nUDID可以关联其它各种数据到相关设备上。例如，连接到开发者账号，可以允许在发布前让设备安装或测试应用；也可以让开发者获得iOS测试版进行体验。苹果用UDID连接到苹果的ID，这些设备可以自动下载和安装从App Store购买的应用、保存从iTunes购买的音乐、帮助苹果发送推送通知、即时消息。 在iOS 应用早期，UDID被第三方应用开发者和网络广告商用来收集用户数据，可以用来关联地址、记录应用使用习惯……以便推送精准广告。\n\n为什么苹果反对开发人员使用UDID？\n\niOS 2.0版本以后UIDevice提供一个获取设备唯一标识符的方法uniqueIdentifier，通过该方法我们可以获取设备的序列号，这个也是目前为止唯一可以确认唯一的标示符。 许多开发者把UDID跟用户的真实姓名、密码、住址、其它数据关联起来；网络窥探者会从多个应用收集这些数据，然后顺藤摸瓜得到这个人的许多隐私数据。同时大部分应用确实在频繁传输UDID和私人信息。 为了避免集体诉讼，苹果最终决定在iOS 5 的时候，将这一惯例废除，开发者被引导生成一个唯一的标识符，只能检测应用程序，其他的信息不提供。现在应用试图获取UDID已被禁止且不允许上架。\n\n所以这个方法作废\n\n### 2、IDFA\n\n全名：advertisingIdentifier\n\n获取代码：\n`  #import <AdSupport/AdSupport.h>\n  NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; `\n来源：iOS6.0及以后\n\n说明：直译就是广告id， 在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪 里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。\n\n注意：由于idfa会出现取不到的情况，故绝不可以作为业务分析的主id，来识别用户。\n\n### 3、IDFV\n\n全名：identifierForVendor\n获取代码：\n`NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString];\n`\n来源：iOS6.0及以后\n\n说明：顾名思义，是给Vendor标识用户用的，每个设备在所属同一个Vender的应用里，都有相同的值。其中的Vender是指应用提供商，但准确点说，是通过BundleID的反转的前两部分进行匹配，如果相同就是同一个Vender，例如对于com.taobao.app1, com.taobao.app2 这两个BundleID来说，就属于同一个Vender，共享同一个idfv的值。和idfa不同的是，idfv的值是一定能取到的，所以非常适合于作为内部用户行为分析的主id，来标识用户，替代OpenUDID。\n\n注意：如果用户将属于此Vender的所有App卸载，则idfv的值会被重置，即再重装此Vender的App，idfv的值和之前不同。\n\n### 4、MAC地址\n\n使用WiFi的mac地址来取代已经废弃了的uniqueIdentifier方法。具体可见:\nhttp://stackoverflow.com/questions/677530/how-can-i-programmatically-get-the-mac-address-of-an-iphone\n\n然而在iOS 7中苹果再一次无情的封杀mac地址，使用之前的方法获取到的mac地址全部都变成了02:00:00:00:00:00。\n\n### 5、Keychain\n\n![](/img/277755-807a54b6dcbeb347.png)\n\n我们可以获取到UUID，然后把UUID保存到KeyChain里面。\n\n这样以后即使APP删了再装回来，也可以从KeyChain中读取回来。使用group还可以可以保证同一个开发商的所有程序针对同一台设备能够获取到相同的不变的UDID。\n\n但是刷机或重装系统后uuid还是会改变。\n\n把下面两个类文件放到你的项目中\n```\nKeychainItemWrapper.h文件\n********************************\n\n#import <UIKit/UIKit.h>\n\n@interface KeychainItemWrapper : NSObject\n{\n    NSMutableDictionary *keychainItemData;        // The actual keychain item data backing store.\n    NSMutableDictionary *genericPasswordQuery;    // A placeholder for the generic keychain item query used to locate the item.\n}\n\n@property (nonatomic, retain) NSMutableDictionary *keychainItemData;\n@property (nonatomic, retain) NSMutableDictionary *genericPasswordQuery;\n\n// Designated initializer.\n- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;\n\n- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;\n- (void)setObject:(id)inObject forKey:(id)key;\n- (id)objectForKey:(id)key;\n\n// Initializes and resets the default generic keychain item data.\n- (void)resetKeychainItem;\n\n@end\n```\n\n```\nKeychainItemWrapper.h文件\n********************************\n\n#import \"KeychainItemWrapper.h\"\n#import <Security/Security.h>\n\n/*\n\nThese are the default constants and their respective types,\navailable for the kSecClassGenericPassword Keychain Item class:\n\nkSecAttrAccessGroup            -        CFStringRef\nkSecAttrCreationDate        -        CFDateRef\nkSecAttrModificationDate    -        CFDateRef\nkSecAttrDescription            -        CFStringRef\nkSecAttrComment                -        CFStringRef\nkSecAttrCreator                -        CFNumberRef\nkSecAttrType                -        CFNumberRef\nkSecAttrLabel                -        CFStringRef\nkSecAttrIsInvisible            -        CFBooleanRef\nkSecAttrIsNegative            -        CFBooleanRef\nkSecAttrAccount                -        CFStringRef\nkSecAttrService                -        CFStringRef\nkSecAttrGeneric                -        CFDataRef\n\nSee the header file Security/SecItem.h for more details.\n\n*/\n\n@interface KeychainItemWrapper (PrivateMethods)\n/*\nThe decision behind the following two methods (secItemFormatToDictionary and dictionaryToSecItemFormat) was\nto encapsulate the transition between what the detail view controller was expecting (NSString *) and what the\nKeychain API expects as a validly constructed container class.\n*/\n- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert;\n- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert;\n\n// Updates the item in the keychain, or adds it if it doesn't exist.\n- (void)writeToKeychain;\n\n@end\n\n@implementation KeychainItemWrapper\n\n@synthesize keychainItemData, genericPasswordQuery;\n\n- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;\n{\n    if (self = [super init])\n    {\n        NSAssert(account != nil || service != nil, @\"Both account and service are nil.  Must specifiy at least one.\");\n        // Begin Keychain search setup. The genericPasswordQuery the attributes kSecAttrAccount and\n        // kSecAttrService are used as unique identifiers differentiating keychain items from one another\n        genericPasswordQuery = [[NSMutableDictionary alloc] init];\n\n        [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];\n\n        [genericPasswordQuery setObject:account forKey:(id)kSecAttrAccount];\n        [genericPasswordQuery setObject:service forKey:(id)kSecAttrService];\n\n        // The keychain access group attribute determines if this item can be shared\n        // amongst multiple apps whose code signing entitlements contain the same keychain access group.\n        if (accessGroup != nil)\n        {\n#if TARGET_IPHONE_SIMULATOR\n            // Ignore the access group if running on the iPhone simulator.\n            //\n            // Apps that are built for the simulator aren't signed, so there's no keychain access group\n            // for the simulator to check. This means that all apps can see all keychain items when run\n            // on the simulator.\n            //\n            // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the\n            // simulator will return -25243 (errSecNoAccessForItem).\n#else\n            [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];\n#endif\n        }\n\n        // Use the proper search constants, return only the attributes of the first match.\n        [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];\n        [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];\n\n        NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];\n\n        NSMutableDictionary *outDictionary = nil;\n\n        if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&outDictionary) == noErr)\n        {\n            // Stick these default values into keychain item if nothing found.\n            [self resetKeychainItem];\n\n            //Adding the account and service identifiers to the keychain\n            [keychainItemData setObject:account forKey:(id)kSecAttrAccount];\n            [keychainItemData setObject:service forKey:(id)kSecAttrService];\n\n            if (accessGroup != nil)\n            {\n#if TARGET_IPHONE_SIMULATOR\n                // Ignore the access group if running on the iPhone simulator.\n                //\n                // Apps that are built for the simulator aren't signed, so there's no keychain access group\n                // for the simulator to check. This means that all apps can see all keychain items when run\n                // on the simulator.\n                //\n                // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the\n                // simulator will return -25243 (errSecNoAccessForItem).\n#else\n                [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];\n#endif\n            }\n        }\n        else\n        {\n            // load the saved data from Keychain.\n            self.keychainItemData = [self secItemFormatToDictionary:outDictionary];\n        }\n\n        [outDictionary release];\n    }\n\n    return self;\n}\n\n- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;\n{\n    if (self = [super init])\n    {\n        // Begin Keychain search setup. The genericPasswordQuery leverages the special user\n        // defined attribute kSecAttrGeneric to distinguish itself between other generic Keychain\n        // items which may be included by the same application.\n        genericPasswordQuery = [[NSMutableDictionary alloc] init];\n\n        [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];\n        [genericPasswordQuery setObject:identifier forKey:(id)kSecAttrGeneric];\n\n        // The keychain access group attribute determines if this item can be shared\n        // amongst multiple apps whose code signing entitlements contain the same keychain access group.\n        if (accessGroup != nil)\n        {\n#if TARGET_IPHONE_SIMULATOR\n            // Ignore the access group if running on the iPhone simulator.\n            // \n            // Apps that are built for the simulator aren't signed, so there's no keychain access group\n            // for the simulator to check. This means that all apps can see all keychain items when run\n            // on the simulator.\n            //\n            // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the\n            // simulator will return -25243 (errSecNoAccessForItem).\n#else            \n            [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];\n#endif\n        }\n\n        // Use the proper search constants, return only the attributes of the first match.\n        [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];\n        [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];\n\n        NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];\n\n        NSMutableDictionary *outDictionary = nil;\n\n        if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&outDictionary) == noErr)\n        {\n            // Stick these default values into keychain item if nothing found.\n            [self resetKeychainItem];\n\n            // Add the generic attribute and the keychain access group.\n            [keychainItemData setObject:identifier forKey:(id)kSecAttrGeneric];\n            if (accessGroup != nil)\n            {\n#if TARGET_IPHONE_SIMULATOR\n                // Ignore the access group if running on the iPhone simulator.\n                // \n                // Apps that are built for the simulator aren't signed, so there's no keychain access group\n                // for the simulator to check. This means that all apps can see all keychain items when run\n                // on the simulator.\n                //\n                // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the\n                // simulator will return -25243 (errSecNoAccessForItem).\n#else            \n                [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];\n#endif\n            }\n        }\n        else\n        {\n            // load the saved data from Keychain.\n            self.keychainItemData = [self secItemFormatToDictionary:outDictionary];\n        }\n\n        [outDictionary release];\n    }\n\n    return self;\n}\n\n- (void)dealloc\n{\n    [keychainItemData release];\n    [genericPasswordQuery release];\n\n    [super dealloc];\n}\n\n- (void)setObject:(id)inObject forKey:(id)key \n{\n    if (inObject == nil) return;\n    id currentObject = [keychainItemData objectForKey:key];\n    if (![currentObject isEqual:inObject])\n    {\n        [keychainItemData setObject:inObject forKey:key];\n        [self writeToKeychain];\n    }\n}\n\n- (id)objectForKey:(id)key\n{\n    return [keychainItemData objectForKey:key];\n}\n\n- (void)resetKeychainItem\n{\n    OSStatus junk = noErr;\n    if (!keychainItemData) \n    {\n        self.keychainItemData = [[NSMutableDictionary alloc] init];\n    }\n    else if (keychainItemData)\n    {\n        NSMutableDictionary *tempDictionary = [self dictionaryToSecItemFormat:keychainItemData];\n        junk = SecItemDelete((CFDictionaryRef)tempDictionary);\n        NSAssert( junk == noErr || junk == errSecItemNotFound, @\"Problem deleting current dictionary.\" );\n    }\n\n    // Default attributes for keychain item.\n    [keychainItemData setObject:@\"\" forKey:(id)kSecAttrAccount];\n    [keychainItemData setObject:@\"\" forKey:(id)kSecAttrLabel];\n    [keychainItemData setObject:@\"\" forKey:(id)kSecAttrDescription];\n\n    // Default data for keychain item.\n    [keychainItemData setObject:@\"\" forKey:(id)kSecValueData];\n}\n\n- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert\n{\n    // The assumption is that this method will be called with a properly populated dictionary\n    // containing all the right key/value pairs for a SecItem.\n\n    // Create a dictionary to return populated with the attributes and data.\n    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];\n\n    // Add the Generic Password keychain item class attribute.\n    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];\n\n    // Convert the NSString to NSData to meet the requirements for the value type kSecValueData.\n    // This is where to store sensitive data that should be encrypted.\n    NSString *passwordString = [dictionaryToConvert objectForKey:(id)kSecValueData];\n    [returnDictionary setObject:[passwordString dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData];\n\n    return returnDictionary;\n}\n\n- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert\n{\n    // The assumption is that this method will be called with a properly populated dictionary\n    // containing all the right key/value pairs for the UI element.\n\n    // Create a dictionary to return populated with the attributes and data.\n    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];\n\n    // Add the proper search key and class attribute.\n    [returnDictionary setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];\n    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];\n\n    // Acquire the password data from the attributes.\n    NSData *passwordData = NULL;\n    if (SecItemCopyMatching((CFDictionaryRef)returnDictionary, (CFTypeRef *)&passwordData) == noErr)\n    {\n        // Remove the search, class, and identifier key/value, we don't need them anymore.\n        [returnDictionary removeObjectForKey:(id)kSecReturnData];\n\n        // Add the password to the dictionary, converting from NSData to NSString.\n        NSString *password = [[[NSString alloc] initWithBytes:[passwordData bytes] length:[passwordData length] \n                                                     encoding:NSUTF8StringEncoding] autorelease];\n        [returnDictionary setObject:password forKey:(id)kSecValueData];\n    }\n    else\n    {\n        // Don't do anything if nothing is found.\n        NSAssert(NO, @\"Serious error, no matching item found in the keychain.\\n\");\n    }\n\n    [passwordData release];\n\n    return returnDictionary;\n}\n\n- (void)writeToKeychain\n{\n    NSDictionary *attributes = NULL;\n    NSMutableDictionary *updateItem = NULL;\n    OSStatus result;\n\n    if (SecItemCopyMatching((CFDictionaryRef)genericPasswordQuery, (CFTypeRef *)&attributes) == noErr)\n    {\n        // First we need the attributes from the Keychain.\n        updateItem = [NSMutableDictionary dictionaryWithDictionary:attributes];\n        // Second we need to add the appropriate search key/values.\n        [updateItem setObject:[genericPasswordQuery objectForKey:(id)kSecClass] forKey:(id)kSecClass];\n\n        // Lastly, we need to set up the updated attribute list being careful to remove the class.\n        NSMutableDictionary *tempCheck = [self dictionaryToSecItemFormat:keychainItemData];\n        [tempCheck removeObjectForKey:(id)kSecClass];\n\n#if TARGET_IPHONE_SIMULATOR\n        // Remove the access group if running on the iPhone simulator.\n        // \n        // Apps that are built for the simulator aren't signed, so there's no keychain access group\n        // for the simulator to check. This means that all apps can see all keychain items when run\n        // on the simulator.\n        //\n        // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the\n        // simulator will return -25243 (errSecNoAccessForItem).\n        //\n        // The access group attribute will be included in items returned by SecItemCopyMatching,\n        // which is why we need to remove it before updating the item.\n        [tempCheck removeObjectForKey:(id)kSecAttrAccessGroup];\n#endif\n\n        // An implicit assumption is that you can only update a single item at a time.\n\n        result = SecItemUpdate((CFDictionaryRef)updateItem, (CFDictionaryRef)tempCheck);\n        NSAssert( result == noErr, @\"Couldn't update the Keychain Item.\" );\n    }\n    else\n    {\n        // No previous item found; add the new one.\n        result = SecItemAdd((CFDictionaryRef)[self dictionaryToSecItemFormat:keychainItemData], NULL);\n        NSAssert( result == noErr, @\"Couldn't add the Keychain Item.\" );\n    }\n}\n\n@end\n```\n我们在写一个工具类用来保存UUID到keychain和从keychain中读取UUID.\n\n**实现代码**\n```\n#pragma mark - 保存和读取UUID\n+(void)saveUUIDToKeyChain{\n    KeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@\"Identfier\" service:@\"AppName\" accessGroup:nil];\n    NSString *string = [keychainItem objectForKey: (__bridge id)kSecAttrGeneric];\n    if([string isEqualToString:@\"\"] || !string){\n        [keychainItem setObject:[self getUUIDString] forKey:(__bridge id)kSecAttrGeneric];\n    }\n}\n\n+(NSString *)readUUIDFromKeyChain{\n    KeychainItemWrapper *keychainItemm = [[KeychainItemWrapper alloc] initWithAccount:@\"Identfier\" service:@\"AppName\" accessGroup:nil];\n    NSString *UUID = [keychainItemm objectForKey: (__bridge id)kSecAttrGeneric];\n    return UUID;\n}\n\n+ (NSString *)getUUIDString\n{\n    CFUUIDRef uuidRef = CFUUIDCreate(kCFAllocatorDefault);\n    CFStringRef strRef = CFUUIDCreateString(kCFAllocatorDefault , uuidRef);\n    NSString *uuidString = [(__bridge NSString*)strRef stringByReplacingOccurrencesOfString:@\"-\" withString:@\"\"];\n    CFRelease(strRef);\n    CFRelease(uuidRef);\n    return uuidString;\n}\n```\n写入UUID到keychain\n\n我们最好在程序启动之后把UUID写入到keychain，代码如下：\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    [AppUtils saveUUIDToKeyChain];\n}\n```\n读取UUID\n\n在需要读取的地方直接调用AppUtils的类方法readUUIDFromKeyChain即可。\n- - - -\n1.让同一开发商的所有APP在同一台设备上获取到UUID相同\n\n在每个APP的项目里面做如下设置\n\n1.1、设置accessgroup\n```\nkeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@\"Identfier\" service:@\"AppName\" accessGroup:@\"YOUR_BUNDLE_SEED.com.yourcompany.userinfo\"];\n\n```\n1.2、创建plist文件\n\n然后在项目相同的目录下创建KeychainAccessGroups.plist文件。\n\n该文件的结构是一个字典，其中中最顶层的节点必须是一个键为“keychain-access-groups”的Array，并且该Array中每一项都是一个描述分组的NSString。YOUR_BUNDLE_SEED.com.yourcompany.userinfo就是要设置的组名。\n\n如图:\n![](/img/277755-72008ba008a56557.png)\n1.3、 设置code signing\n\n接着在Target--->Build Settings---->Code Signing栏下的Code Signing Entitlements右侧添加KeychainAccessGroups.plist\n\n如图：\n![](/img/277755-e736892057d71333.png)\n\n这样就可以保证每个app都是从keychain中读取出来同一个UUID\n","source":"_posts/获取iOS设备唯一标示UUID (转发).md","raw":"---\ntitle: 获取iOS设备唯一标示UUID (转发来源简书)\ndate: 2017-04-21 09:30:00\ntags:\n---\n\n在开发过程中，我们经常会被要求获取每个设备的唯一标示，以便后台做相应的处理。我们来看看有哪些方法来获取设备的唯一标示，然后再分析下这些方法的利弊。\n\n具体可以分为如下几种：\n\n1. UDID\n2. IDFA\n3. IDFV\n4. MAC\n5. keychain\n- - - -\n下面我们来具体分析下每种获取方法的利弊\n### 1、UDID\n\n什么是UDID\n\nUDID 「Unique Device Identifier Description」是由子母和数字组成的40个字符串的序号，用来区别每一个唯一的iOS设备，包括 iPhones, iPads, 以及 iPod touches，这些编码看起来是随机的，实际上是跟硬件设备特点相联系的，另外你可以到iTunes，pp助手或itools等软件查看你的udid（设备标识）\n\nUDID是用来干什么的？\n\nUDID可以关联其它各种数据到相关设备上。例如，连接到开发者账号，可以允许在发布前让设备安装或测试应用；也可以让开发者获得iOS测试版进行体验。苹果用UDID连接到苹果的ID，这些设备可以自动下载和安装从App Store购买的应用、保存从iTunes购买的音乐、帮助苹果发送推送通知、即时消息。 在iOS 应用早期，UDID被第三方应用开发者和网络广告商用来收集用户数据，可以用来关联地址、记录应用使用习惯……以便推送精准广告。\n\n为什么苹果反对开发人员使用UDID？\n\niOS 2.0版本以后UIDevice提供一个获取设备唯一标识符的方法uniqueIdentifier，通过该方法我们可以获取设备的序列号，这个也是目前为止唯一可以确认唯一的标示符。 许多开发者把UDID跟用户的真实姓名、密码、住址、其它数据关联起来；网络窥探者会从多个应用收集这些数据，然后顺藤摸瓜得到这个人的许多隐私数据。同时大部分应用确实在频繁传输UDID和私人信息。 为了避免集体诉讼，苹果最终决定在iOS 5 的时候，将这一惯例废除，开发者被引导生成一个唯一的标识符，只能检测应用程序，其他的信息不提供。现在应用试图获取UDID已被禁止且不允许上架。\n\n所以这个方法作废\n\n### 2、IDFA\n\n全名：advertisingIdentifier\n\n获取代码：\n`  #import <AdSupport/AdSupport.h>\n  NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; `\n来源：iOS6.0及以后\n\n说明：直译就是广告id， 在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪 里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。\n\n注意：由于idfa会出现取不到的情况，故绝不可以作为业务分析的主id，来识别用户。\n\n### 3、IDFV\n\n全名：identifierForVendor\n获取代码：\n`NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString];\n`\n来源：iOS6.0及以后\n\n说明：顾名思义，是给Vendor标识用户用的，每个设备在所属同一个Vender的应用里，都有相同的值。其中的Vender是指应用提供商，但准确点说，是通过BundleID的反转的前两部分进行匹配，如果相同就是同一个Vender，例如对于com.taobao.app1, com.taobao.app2 这两个BundleID来说，就属于同一个Vender，共享同一个idfv的值。和idfa不同的是，idfv的值是一定能取到的，所以非常适合于作为内部用户行为分析的主id，来标识用户，替代OpenUDID。\n\n注意：如果用户将属于此Vender的所有App卸载，则idfv的值会被重置，即再重装此Vender的App，idfv的值和之前不同。\n\n### 4、MAC地址\n\n使用WiFi的mac地址来取代已经废弃了的uniqueIdentifier方法。具体可见:\nhttp://stackoverflow.com/questions/677530/how-can-i-programmatically-get-the-mac-address-of-an-iphone\n\n然而在iOS 7中苹果再一次无情的封杀mac地址，使用之前的方法获取到的mac地址全部都变成了02:00:00:00:00:00。\n\n### 5、Keychain\n\n![](/img/277755-807a54b6dcbeb347.png)\n\n我们可以获取到UUID，然后把UUID保存到KeyChain里面。\n\n这样以后即使APP删了再装回来，也可以从KeyChain中读取回来。使用group还可以可以保证同一个开发商的所有程序针对同一台设备能够获取到相同的不变的UDID。\n\n但是刷机或重装系统后uuid还是会改变。\n\n把下面两个类文件放到你的项目中\n```\nKeychainItemWrapper.h文件\n********************************\n\n#import <UIKit/UIKit.h>\n\n@interface KeychainItemWrapper : NSObject\n{\n    NSMutableDictionary *keychainItemData;        // The actual keychain item data backing store.\n    NSMutableDictionary *genericPasswordQuery;    // A placeholder for the generic keychain item query used to locate the item.\n}\n\n@property (nonatomic, retain) NSMutableDictionary *keychainItemData;\n@property (nonatomic, retain) NSMutableDictionary *genericPasswordQuery;\n\n// Designated initializer.\n- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;\n\n- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;\n- (void)setObject:(id)inObject forKey:(id)key;\n- (id)objectForKey:(id)key;\n\n// Initializes and resets the default generic keychain item data.\n- (void)resetKeychainItem;\n\n@end\n```\n\n```\nKeychainItemWrapper.h文件\n********************************\n\n#import \"KeychainItemWrapper.h\"\n#import <Security/Security.h>\n\n/*\n\nThese are the default constants and their respective types,\navailable for the kSecClassGenericPassword Keychain Item class:\n\nkSecAttrAccessGroup            -        CFStringRef\nkSecAttrCreationDate        -        CFDateRef\nkSecAttrModificationDate    -        CFDateRef\nkSecAttrDescription            -        CFStringRef\nkSecAttrComment                -        CFStringRef\nkSecAttrCreator                -        CFNumberRef\nkSecAttrType                -        CFNumberRef\nkSecAttrLabel                -        CFStringRef\nkSecAttrIsInvisible            -        CFBooleanRef\nkSecAttrIsNegative            -        CFBooleanRef\nkSecAttrAccount                -        CFStringRef\nkSecAttrService                -        CFStringRef\nkSecAttrGeneric                -        CFDataRef\n\nSee the header file Security/SecItem.h for more details.\n\n*/\n\n@interface KeychainItemWrapper (PrivateMethods)\n/*\nThe decision behind the following two methods (secItemFormatToDictionary and dictionaryToSecItemFormat) was\nto encapsulate the transition between what the detail view controller was expecting (NSString *) and what the\nKeychain API expects as a validly constructed container class.\n*/\n- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert;\n- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert;\n\n// Updates the item in the keychain, or adds it if it doesn't exist.\n- (void)writeToKeychain;\n\n@end\n\n@implementation KeychainItemWrapper\n\n@synthesize keychainItemData, genericPasswordQuery;\n\n- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;\n{\n    if (self = [super init])\n    {\n        NSAssert(account != nil || service != nil, @\"Both account and service are nil.  Must specifiy at least one.\");\n        // Begin Keychain search setup. The genericPasswordQuery the attributes kSecAttrAccount and\n        // kSecAttrService are used as unique identifiers differentiating keychain items from one another\n        genericPasswordQuery = [[NSMutableDictionary alloc] init];\n\n        [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];\n\n        [genericPasswordQuery setObject:account forKey:(id)kSecAttrAccount];\n        [genericPasswordQuery setObject:service forKey:(id)kSecAttrService];\n\n        // The keychain access group attribute determines if this item can be shared\n        // amongst multiple apps whose code signing entitlements contain the same keychain access group.\n        if (accessGroup != nil)\n        {\n#if TARGET_IPHONE_SIMULATOR\n            // Ignore the access group if running on the iPhone simulator.\n            //\n            // Apps that are built for the simulator aren't signed, so there's no keychain access group\n            // for the simulator to check. This means that all apps can see all keychain items when run\n            // on the simulator.\n            //\n            // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the\n            // simulator will return -25243 (errSecNoAccessForItem).\n#else\n            [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];\n#endif\n        }\n\n        // Use the proper search constants, return only the attributes of the first match.\n        [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];\n        [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];\n\n        NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];\n\n        NSMutableDictionary *outDictionary = nil;\n\n        if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&outDictionary) == noErr)\n        {\n            // Stick these default values into keychain item if nothing found.\n            [self resetKeychainItem];\n\n            //Adding the account and service identifiers to the keychain\n            [keychainItemData setObject:account forKey:(id)kSecAttrAccount];\n            [keychainItemData setObject:service forKey:(id)kSecAttrService];\n\n            if (accessGroup != nil)\n            {\n#if TARGET_IPHONE_SIMULATOR\n                // Ignore the access group if running on the iPhone simulator.\n                //\n                // Apps that are built for the simulator aren't signed, so there's no keychain access group\n                // for the simulator to check. This means that all apps can see all keychain items when run\n                // on the simulator.\n                //\n                // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the\n                // simulator will return -25243 (errSecNoAccessForItem).\n#else\n                [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];\n#endif\n            }\n        }\n        else\n        {\n            // load the saved data from Keychain.\n            self.keychainItemData = [self secItemFormatToDictionary:outDictionary];\n        }\n\n        [outDictionary release];\n    }\n\n    return self;\n}\n\n- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;\n{\n    if (self = [super init])\n    {\n        // Begin Keychain search setup. The genericPasswordQuery leverages the special user\n        // defined attribute kSecAttrGeneric to distinguish itself between other generic Keychain\n        // items which may be included by the same application.\n        genericPasswordQuery = [[NSMutableDictionary alloc] init];\n\n        [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];\n        [genericPasswordQuery setObject:identifier forKey:(id)kSecAttrGeneric];\n\n        // The keychain access group attribute determines if this item can be shared\n        // amongst multiple apps whose code signing entitlements contain the same keychain access group.\n        if (accessGroup != nil)\n        {\n#if TARGET_IPHONE_SIMULATOR\n            // Ignore the access group if running on the iPhone simulator.\n            // \n            // Apps that are built for the simulator aren't signed, so there's no keychain access group\n            // for the simulator to check. This means that all apps can see all keychain items when run\n            // on the simulator.\n            //\n            // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the\n            // simulator will return -25243 (errSecNoAccessForItem).\n#else            \n            [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];\n#endif\n        }\n\n        // Use the proper search constants, return only the attributes of the first match.\n        [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];\n        [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];\n\n        NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];\n\n        NSMutableDictionary *outDictionary = nil;\n\n        if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&outDictionary) == noErr)\n        {\n            // Stick these default values into keychain item if nothing found.\n            [self resetKeychainItem];\n\n            // Add the generic attribute and the keychain access group.\n            [keychainItemData setObject:identifier forKey:(id)kSecAttrGeneric];\n            if (accessGroup != nil)\n            {\n#if TARGET_IPHONE_SIMULATOR\n                // Ignore the access group if running on the iPhone simulator.\n                // \n                // Apps that are built for the simulator aren't signed, so there's no keychain access group\n                // for the simulator to check. This means that all apps can see all keychain items when run\n                // on the simulator.\n                //\n                // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the\n                // simulator will return -25243 (errSecNoAccessForItem).\n#else            \n                [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];\n#endif\n            }\n        }\n        else\n        {\n            // load the saved data from Keychain.\n            self.keychainItemData = [self secItemFormatToDictionary:outDictionary];\n        }\n\n        [outDictionary release];\n    }\n\n    return self;\n}\n\n- (void)dealloc\n{\n    [keychainItemData release];\n    [genericPasswordQuery release];\n\n    [super dealloc];\n}\n\n- (void)setObject:(id)inObject forKey:(id)key \n{\n    if (inObject == nil) return;\n    id currentObject = [keychainItemData objectForKey:key];\n    if (![currentObject isEqual:inObject])\n    {\n        [keychainItemData setObject:inObject forKey:key];\n        [self writeToKeychain];\n    }\n}\n\n- (id)objectForKey:(id)key\n{\n    return [keychainItemData objectForKey:key];\n}\n\n- (void)resetKeychainItem\n{\n    OSStatus junk = noErr;\n    if (!keychainItemData) \n    {\n        self.keychainItemData = [[NSMutableDictionary alloc] init];\n    }\n    else if (keychainItemData)\n    {\n        NSMutableDictionary *tempDictionary = [self dictionaryToSecItemFormat:keychainItemData];\n        junk = SecItemDelete((CFDictionaryRef)tempDictionary);\n        NSAssert( junk == noErr || junk == errSecItemNotFound, @\"Problem deleting current dictionary.\" );\n    }\n\n    // Default attributes for keychain item.\n    [keychainItemData setObject:@\"\" forKey:(id)kSecAttrAccount];\n    [keychainItemData setObject:@\"\" forKey:(id)kSecAttrLabel];\n    [keychainItemData setObject:@\"\" forKey:(id)kSecAttrDescription];\n\n    // Default data for keychain item.\n    [keychainItemData setObject:@\"\" forKey:(id)kSecValueData];\n}\n\n- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert\n{\n    // The assumption is that this method will be called with a properly populated dictionary\n    // containing all the right key/value pairs for a SecItem.\n\n    // Create a dictionary to return populated with the attributes and data.\n    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];\n\n    // Add the Generic Password keychain item class attribute.\n    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];\n\n    // Convert the NSString to NSData to meet the requirements for the value type kSecValueData.\n    // This is where to store sensitive data that should be encrypted.\n    NSString *passwordString = [dictionaryToConvert objectForKey:(id)kSecValueData];\n    [returnDictionary setObject:[passwordString dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData];\n\n    return returnDictionary;\n}\n\n- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert\n{\n    // The assumption is that this method will be called with a properly populated dictionary\n    // containing all the right key/value pairs for the UI element.\n\n    // Create a dictionary to return populated with the attributes and data.\n    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];\n\n    // Add the proper search key and class attribute.\n    [returnDictionary setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];\n    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];\n\n    // Acquire the password data from the attributes.\n    NSData *passwordData = NULL;\n    if (SecItemCopyMatching((CFDictionaryRef)returnDictionary, (CFTypeRef *)&passwordData) == noErr)\n    {\n        // Remove the search, class, and identifier key/value, we don't need them anymore.\n        [returnDictionary removeObjectForKey:(id)kSecReturnData];\n\n        // Add the password to the dictionary, converting from NSData to NSString.\n        NSString *password = [[[NSString alloc] initWithBytes:[passwordData bytes] length:[passwordData length] \n                                                     encoding:NSUTF8StringEncoding] autorelease];\n        [returnDictionary setObject:password forKey:(id)kSecValueData];\n    }\n    else\n    {\n        // Don't do anything if nothing is found.\n        NSAssert(NO, @\"Serious error, no matching item found in the keychain.\\n\");\n    }\n\n    [passwordData release];\n\n    return returnDictionary;\n}\n\n- (void)writeToKeychain\n{\n    NSDictionary *attributes = NULL;\n    NSMutableDictionary *updateItem = NULL;\n    OSStatus result;\n\n    if (SecItemCopyMatching((CFDictionaryRef)genericPasswordQuery, (CFTypeRef *)&attributes) == noErr)\n    {\n        // First we need the attributes from the Keychain.\n        updateItem = [NSMutableDictionary dictionaryWithDictionary:attributes];\n        // Second we need to add the appropriate search key/values.\n        [updateItem setObject:[genericPasswordQuery objectForKey:(id)kSecClass] forKey:(id)kSecClass];\n\n        // Lastly, we need to set up the updated attribute list being careful to remove the class.\n        NSMutableDictionary *tempCheck = [self dictionaryToSecItemFormat:keychainItemData];\n        [tempCheck removeObjectForKey:(id)kSecClass];\n\n#if TARGET_IPHONE_SIMULATOR\n        // Remove the access group if running on the iPhone simulator.\n        // \n        // Apps that are built for the simulator aren't signed, so there's no keychain access group\n        // for the simulator to check. This means that all apps can see all keychain items when run\n        // on the simulator.\n        //\n        // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the\n        // simulator will return -25243 (errSecNoAccessForItem).\n        //\n        // The access group attribute will be included in items returned by SecItemCopyMatching,\n        // which is why we need to remove it before updating the item.\n        [tempCheck removeObjectForKey:(id)kSecAttrAccessGroup];\n#endif\n\n        // An implicit assumption is that you can only update a single item at a time.\n\n        result = SecItemUpdate((CFDictionaryRef)updateItem, (CFDictionaryRef)tempCheck);\n        NSAssert( result == noErr, @\"Couldn't update the Keychain Item.\" );\n    }\n    else\n    {\n        // No previous item found; add the new one.\n        result = SecItemAdd((CFDictionaryRef)[self dictionaryToSecItemFormat:keychainItemData], NULL);\n        NSAssert( result == noErr, @\"Couldn't add the Keychain Item.\" );\n    }\n}\n\n@end\n```\n我们在写一个工具类用来保存UUID到keychain和从keychain中读取UUID.\n\n**实现代码**\n```\n#pragma mark - 保存和读取UUID\n+(void)saveUUIDToKeyChain{\n    KeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@\"Identfier\" service:@\"AppName\" accessGroup:nil];\n    NSString *string = [keychainItem objectForKey: (__bridge id)kSecAttrGeneric];\n    if([string isEqualToString:@\"\"] || !string){\n        [keychainItem setObject:[self getUUIDString] forKey:(__bridge id)kSecAttrGeneric];\n    }\n}\n\n+(NSString *)readUUIDFromKeyChain{\n    KeychainItemWrapper *keychainItemm = [[KeychainItemWrapper alloc] initWithAccount:@\"Identfier\" service:@\"AppName\" accessGroup:nil];\n    NSString *UUID = [keychainItemm objectForKey: (__bridge id)kSecAttrGeneric];\n    return UUID;\n}\n\n+ (NSString *)getUUIDString\n{\n    CFUUIDRef uuidRef = CFUUIDCreate(kCFAllocatorDefault);\n    CFStringRef strRef = CFUUIDCreateString(kCFAllocatorDefault , uuidRef);\n    NSString *uuidString = [(__bridge NSString*)strRef stringByReplacingOccurrencesOfString:@\"-\" withString:@\"\"];\n    CFRelease(strRef);\n    CFRelease(uuidRef);\n    return uuidString;\n}\n```\n写入UUID到keychain\n\n我们最好在程序启动之后把UUID写入到keychain，代码如下：\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    [AppUtils saveUUIDToKeyChain];\n}\n```\n读取UUID\n\n在需要读取的地方直接调用AppUtils的类方法readUUIDFromKeyChain即可。\n- - - -\n1.让同一开发商的所有APP在同一台设备上获取到UUID相同\n\n在每个APP的项目里面做如下设置\n\n1.1、设置accessgroup\n```\nkeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@\"Identfier\" service:@\"AppName\" accessGroup:@\"YOUR_BUNDLE_SEED.com.yourcompany.userinfo\"];\n\n```\n1.2、创建plist文件\n\n然后在项目相同的目录下创建KeychainAccessGroups.plist文件。\n\n该文件的结构是一个字典，其中中最顶层的节点必须是一个键为“keychain-access-groups”的Array，并且该Array中每一项都是一个描述分组的NSString。YOUR_BUNDLE_SEED.com.yourcompany.userinfo就是要设置的组名。\n\n如图:\n![](/img/277755-72008ba008a56557.png)\n1.3、 设置code signing\n\n接着在Target--->Build Settings---->Code Signing栏下的Code Signing Entitlements右侧添加KeychainAccessGroups.plist\n\n如图：\n![](/img/277755-e736892057d71333.png)\n\n这样就可以保证每个app都是从keychain中读取出来同一个UUID\n","slug":"获取iOS设备唯一标示UUID (转发)","published":1,"updated":"2017-04-21T01:37:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1r65i6v0000zd4t0t2wzapj","content":"<p>在开发过程中，我们经常会被要求获取每个设备的唯一标示，以便后台做相应的处理。我们来看看有哪些方法来获取设备的唯一标示，然后再分析下这些方法的利弊。</p>\n<p>具体可以分为如下几种：</p>\n<ol>\n<li>UDID</li>\n<li>IDFA</li>\n<li>IDFV</li>\n<li>MAC</li>\n<li>keychain</li>\n</ol>\n<hr>\n<p>下面我们来具体分析下每种获取方法的利弊</p>\n<h3>1、UDID</h3>\n<p>什么是UDID</p>\n<p>UDID 「Unique Device Identifier Description」是由子母和数字组成的40个字符串的序号，用来区别每一个唯一的iOS设备，包括 iPhones, iPads, 以及 iPod touches，这些编码看起来是随机的，实际上是跟硬件设备特点相联系的，另外你可以到iTunes，pp助手或itools等软件查看你的udid（设备标识）</p>\n<p>UDID是用来干什么的？</p>\n<p>UDID可以关联其它各种数据到相关设备上。例如，连接到开发者账号，可以允许在发布前让设备安装或测试应用；也可以让开发者获得iOS测试版进行体验。苹果用UDID连接到苹果的ID，这些设备可以自动下载和安装从App Store购买的应用、保存从iTunes购买的音乐、帮助苹果发送推送通知、即时消息。 在iOS 应用早期，UDID被第三方应用开发者和网络广告商用来收集用户数据，可以用来关联地址、记录应用使用习惯……以便推送精准广告。</p>\n<p>为什么苹果反对开发人员使用UDID？</p>\n<p>iOS 2.0版本以后UIDevice提供一个获取设备唯一标识符的方法uniqueIdentifier，通过该方法我们可以获取设备的序列号，这个也是目前为止唯一可以确认唯一的标示符。 许多开发者把UDID跟用户的真实姓名、密码、住址、其它数据关联起来；网络窥探者会从多个应用收集这些数据，然后顺藤摸瓜得到这个人的许多隐私数据。同时大部分应用确实在频繁传输UDID和私人信息。 为了避免集体诉讼，苹果最终决定在iOS 5 的时候，将这一惯例废除，开发者被引导生成一个唯一的标识符，只能检测应用程序，其他的信息不提供。现在应用试图获取UDID已被禁止且不允许上架。</p>\n<p>所以这个方法作废</p>\n<h3>2、IDFA</h3>\n<p>全名：advertisingIdentifier</p>\n<p>获取代码：\n<code>#import &lt;AdSupport/AdSupport.h&gt; NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];</code>\n来源：iOS6.0及以后</p>\n<p>说明：直译就是广告id， 在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪 里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。</p>\n<p>注意：由于idfa会出现取不到的情况，故绝不可以作为业务分析的主id，来识别用户。</p>\n<h3>3、IDFV</h3>\n<p>全名：identifierForVendor\n获取代码：\n<code>NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString];</code>\n来源：iOS6.0及以后</p>\n<p>说明：顾名思义，是给Vendor标识用户用的，每个设备在所属同一个Vender的应用里，都有相同的值。其中的Vender是指应用提供商，但准确点说，是通过BundleID的反转的前两部分进行匹配，如果相同就是同一个Vender，例如对于com.taobao.app1, com.taobao.app2 这两个BundleID来说，就属于同一个Vender，共享同一个idfv的值。和idfa不同的是，idfv的值是一定能取到的，所以非常适合于作为内部用户行为分析的主id，来标识用户，替代OpenUDID。</p>\n<p>注意：如果用户将属于此Vender的所有App卸载，则idfv的值会被重置，即再重装此Vender的App，idfv的值和之前不同。</p>\n<h3>4、MAC地址</h3>\n<p>使用WiFi的mac地址来取代已经废弃了的uniqueIdentifier方法。具体可见:\nhttp://stackoverflow.com/questions/677530/how-can-i-programmatically-get-the-mac-address-of-an-iphone</p>\n<p>然而在iOS 7中苹果再一次无情的封杀mac地址，使用之前的方法获取到的mac地址全部都变成了02:00:00:00:00:00。</p>\n<h3>5、Keychain</h3>\n<p><img src=\"/img/277755-807a54b6dcbeb347.png\" alt=\"\"></p>\n<p>我们可以获取到UUID，然后把UUID保存到KeyChain里面。</p>\n<p>这样以后即使APP删了再装回来，也可以从KeyChain中读取回来。使用group还可以可以保证同一个开发商的所有程序针对同一台设备能够获取到相同的不变的UDID。</p>\n<p>但是刷机或重装系统后uuid还是会改变。</p>\n<p>把下面两个类文件放到你的项目中\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">KeychainItemWrapper.h文件</div><div class=\"line\">********************************</div><div class=\"line\"></div><div class=\"line\">#import &lt;UIKit/UIKit.h&gt;</div><div class=\"line\"></div><div class=\"line\">@interface KeychainItemWrapper : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">    NSMutableDictionary *keychainItemData;        // The actual keychain item data backing store.</div><div class=\"line\">    NSMutableDictionary *genericPasswordQuery;    // A placeholder for the generic keychain item query used to locate the item.</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, retain) NSMutableDictionary *keychainItemData;</div><div class=\"line\">@property (nonatomic, retain) NSMutableDictionary *genericPasswordQuery;</div><div class=\"line\"></div><div class=\"line\">// Designated initializer.</div><div class=\"line\">- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;</div><div class=\"line\">- (void)setObject:(id)inObject forKey:(id)key;</div><div class=\"line\">- (id)objectForKey:(id)key;</div><div class=\"line\"></div><div class=\"line\">// Initializes and resets the default generic keychain item data.</div><div class=\"line\">- (void)resetKeychainItem;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div></pre></td><td class=\"code\"><pre><div class=\"line\">KeychainItemWrapper.h文件</div><div class=\"line\">********************************</div><div class=\"line\"></div><div class=\"line\">#import &quot;KeychainItemWrapper.h&quot;</div><div class=\"line\">#import &lt;Security/Security.h&gt;</div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\"></div><div class=\"line\">These are the default constants and their respective types,</div><div class=\"line\">available for the kSecClassGenericPassword Keychain Item class:</div><div class=\"line\"></div><div class=\"line\">kSecAttrAccessGroup            -        CFStringRef</div><div class=\"line\">kSecAttrCreationDate        -        CFDateRef</div><div class=\"line\">kSecAttrModificationDate    -        CFDateRef</div><div class=\"line\">kSecAttrDescription            -        CFStringRef</div><div class=\"line\">kSecAttrComment                -        CFStringRef</div><div class=\"line\">kSecAttrCreator                -        CFNumberRef</div><div class=\"line\">kSecAttrType                -        CFNumberRef</div><div class=\"line\">kSecAttrLabel                -        CFStringRef</div><div class=\"line\">kSecAttrIsInvisible            -        CFBooleanRef</div><div class=\"line\">kSecAttrIsNegative            -        CFBooleanRef</div><div class=\"line\">kSecAttrAccount                -        CFStringRef</div><div class=\"line\">kSecAttrService                -        CFStringRef</div><div class=\"line\">kSecAttrGeneric                -        CFDataRef</div><div class=\"line\"></div><div class=\"line\">See the header file Security/SecItem.h for more details.</div><div class=\"line\"></div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\">@interface KeychainItemWrapper (PrivateMethods)</div><div class=\"line\">/*</div><div class=\"line\">The decision behind the following two methods (secItemFormatToDictionary and dictionaryToSecItemFormat) was</div><div class=\"line\">to encapsulate the transition between what the detail view controller was expecting (NSString *) and what the</div><div class=\"line\">Keychain API expects as a validly constructed container class.</div><div class=\"line\">*/</div><div class=\"line\">- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert;</div><div class=\"line\">- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert;</div><div class=\"line\"></div><div class=\"line\">// Updates the item in the keychain, or adds it if it doesn&apos;t exist.</div><div class=\"line\">- (void)writeToKeychain;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation KeychainItemWrapper</div><div class=\"line\"></div><div class=\"line\">@synthesize keychainItemData, genericPasswordQuery;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self = [super init])</div><div class=\"line\">    &#123;</div><div class=\"line\">        NSAssert(account != nil || service != nil, @&quot;Both account and service are nil.  Must specifiy at least one.&quot;);</div><div class=\"line\">        // Begin Keychain search setup. The genericPasswordQuery the attributes kSecAttrAccount and</div><div class=\"line\">        // kSecAttrService are used as unique identifiers differentiating keychain items from one another</div><div class=\"line\">        genericPasswordQuery = [[NSMutableDictionary alloc] init];</div><div class=\"line\"></div><div class=\"line\">        [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];</div><div class=\"line\"></div><div class=\"line\">        [genericPasswordQuery setObject:account forKey:(id)kSecAttrAccount];</div><div class=\"line\">        [genericPasswordQuery setObject:service forKey:(id)kSecAttrService];</div><div class=\"line\"></div><div class=\"line\">        // The keychain access group attribute determines if this item can be shared</div><div class=\"line\">        // amongst multiple apps whose code signing entitlements contain the same keychain access group.</div><div class=\"line\">        if (accessGroup != nil)</div><div class=\"line\">        &#123;</div><div class=\"line\">#if TARGET_IPHONE_SIMULATOR</div><div class=\"line\">            // Ignore the access group if running on the iPhone simulator.</div><div class=\"line\">            //</div><div class=\"line\">            // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</div><div class=\"line\">            // for the simulator to check. This means that all apps can see all keychain items when run</div><div class=\"line\">            // on the simulator.</div><div class=\"line\">            //</div><div class=\"line\">            // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</div><div class=\"line\">            // simulator will return -25243 (errSecNoAccessForItem).</div><div class=\"line\">#else</div><div class=\"line\">            [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Use the proper search constants, return only the attributes of the first match.</div><div class=\"line\">        [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];</div><div class=\"line\">        [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];</div><div class=\"line\"></div><div class=\"line\">        NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];</div><div class=\"line\"></div><div class=\"line\">        NSMutableDictionary *outDictionary = nil;</div><div class=\"line\"></div><div class=\"line\">        if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;outDictionary) == noErr)</div><div class=\"line\">        &#123;</div><div class=\"line\">            // Stick these default values into keychain item if nothing found.</div><div class=\"line\">            [self resetKeychainItem];</div><div class=\"line\"></div><div class=\"line\">            //Adding the account and service identifiers to the keychain</div><div class=\"line\">            [keychainItemData setObject:account forKey:(id)kSecAttrAccount];</div><div class=\"line\">            [keychainItemData setObject:service forKey:(id)kSecAttrService];</div><div class=\"line\"></div><div class=\"line\">            if (accessGroup != nil)</div><div class=\"line\">            &#123;</div><div class=\"line\">#if TARGET_IPHONE_SIMULATOR</div><div class=\"line\">                // Ignore the access group if running on the iPhone simulator.</div><div class=\"line\">                //</div><div class=\"line\">                // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</div><div class=\"line\">                // for the simulator to check. This means that all apps can see all keychain items when run</div><div class=\"line\">                // on the simulator.</div><div class=\"line\">                //</div><div class=\"line\">                // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</div><div class=\"line\">                // simulator will return -25243 (errSecNoAccessForItem).</div><div class=\"line\">#else</div><div class=\"line\">                [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];</div><div class=\"line\">#endif</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">            // load the saved data from Keychain.</div><div class=\"line\">            self.keychainItemData = [self secItemFormatToDictionary:outDictionary];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        [outDictionary release];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self = [super init])</div><div class=\"line\">    &#123;</div><div class=\"line\">        // Begin Keychain search setup. The genericPasswordQuery leverages the special user</div><div class=\"line\">        // defined attribute kSecAttrGeneric to distinguish itself between other generic Keychain</div><div class=\"line\">        // items which may be included by the same application.</div><div class=\"line\">        genericPasswordQuery = [[NSMutableDictionary alloc] init];</div><div class=\"line\"></div><div class=\"line\">        [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];</div><div class=\"line\">        [genericPasswordQuery setObject:identifier forKey:(id)kSecAttrGeneric];</div><div class=\"line\"></div><div class=\"line\">        // The keychain access group attribute determines if this item can be shared</div><div class=\"line\">        // amongst multiple apps whose code signing entitlements contain the same keychain access group.</div><div class=\"line\">        if (accessGroup != nil)</div><div class=\"line\">        &#123;</div><div class=\"line\">#if TARGET_IPHONE_SIMULATOR</div><div class=\"line\">            // Ignore the access group if running on the iPhone simulator.</div><div class=\"line\">            // </div><div class=\"line\">            // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</div><div class=\"line\">            // for the simulator to check. This means that all apps can see all keychain items when run</div><div class=\"line\">            // on the simulator.</div><div class=\"line\">            //</div><div class=\"line\">            // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</div><div class=\"line\">            // simulator will return -25243 (errSecNoAccessForItem).</div><div class=\"line\">#else            </div><div class=\"line\">            [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Use the proper search constants, return only the attributes of the first match.</div><div class=\"line\">        [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];</div><div class=\"line\">        [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];</div><div class=\"line\"></div><div class=\"line\">        NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];</div><div class=\"line\"></div><div class=\"line\">        NSMutableDictionary *outDictionary = nil;</div><div class=\"line\"></div><div class=\"line\">        if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;outDictionary) == noErr)</div><div class=\"line\">        &#123;</div><div class=\"line\">            // Stick these default values into keychain item if nothing found.</div><div class=\"line\">            [self resetKeychainItem];</div><div class=\"line\"></div><div class=\"line\">            // Add the generic attribute and the keychain access group.</div><div class=\"line\">            [keychainItemData setObject:identifier forKey:(id)kSecAttrGeneric];</div><div class=\"line\">            if (accessGroup != nil)</div><div class=\"line\">            &#123;</div><div class=\"line\">#if TARGET_IPHONE_SIMULATOR</div><div class=\"line\">                // Ignore the access group if running on the iPhone simulator.</div><div class=\"line\">                // </div><div class=\"line\">                // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</div><div class=\"line\">                // for the simulator to check. This means that all apps can see all keychain items when run</div><div class=\"line\">                // on the simulator.</div><div class=\"line\">                //</div><div class=\"line\">                // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</div><div class=\"line\">                // simulator will return -25243 (errSecNoAccessForItem).</div><div class=\"line\">#else            </div><div class=\"line\">                [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];</div><div class=\"line\">#endif</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">            // load the saved data from Keychain.</div><div class=\"line\">            self.keychainItemData = [self secItemFormatToDictionary:outDictionary];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        [outDictionary release];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)dealloc</div><div class=\"line\">&#123;</div><div class=\"line\">    [keychainItemData release];</div><div class=\"line\">    [genericPasswordQuery release];</div><div class=\"line\"></div><div class=\"line\">    [super dealloc];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setObject:(id)inObject forKey:(id)key </div><div class=\"line\">&#123;</div><div class=\"line\">    if (inObject == nil) return;</div><div class=\"line\">    id currentObject = [keychainItemData objectForKey:key];</div><div class=\"line\">    if (![currentObject isEqual:inObject])</div><div class=\"line\">    &#123;</div><div class=\"line\">        [keychainItemData setObject:inObject forKey:key];</div><div class=\"line\">        [self writeToKeychain];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)objectForKey:(id)key</div><div class=\"line\">&#123;</div><div class=\"line\">    return [keychainItemData objectForKey:key];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)resetKeychainItem</div><div class=\"line\">&#123;</div><div class=\"line\">    OSStatus junk = noErr;</div><div class=\"line\">    if (!keychainItemData) </div><div class=\"line\">    &#123;</div><div class=\"line\">        self.keychainItemData = [[NSMutableDictionary alloc] init];</div><div class=\"line\">    &#125;</div><div class=\"line\">    else if (keychainItemData)</div><div class=\"line\">    &#123;</div><div class=\"line\">        NSMutableDictionary *tempDictionary = [self dictionaryToSecItemFormat:keychainItemData];</div><div class=\"line\">        junk = SecItemDelete((CFDictionaryRef)tempDictionary);</div><div class=\"line\">        NSAssert( junk == noErr || junk == errSecItemNotFound, @&quot;Problem deleting current dictionary.&quot; );</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Default attributes for keychain item.</div><div class=\"line\">    [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecAttrAccount];</div><div class=\"line\">    [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecAttrLabel];</div><div class=\"line\">    [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecAttrDescription];</div><div class=\"line\"></div><div class=\"line\">    // Default data for keychain item.</div><div class=\"line\">    [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecValueData];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert</div><div class=\"line\">&#123;</div><div class=\"line\">    // The assumption is that this method will be called with a properly populated dictionary</div><div class=\"line\">    // containing all the right key/value pairs for a SecItem.</div><div class=\"line\"></div><div class=\"line\">    // Create a dictionary to return populated with the attributes and data.</div><div class=\"line\">    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];</div><div class=\"line\"></div><div class=\"line\">    // Add the Generic Password keychain item class attribute.</div><div class=\"line\">    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];</div><div class=\"line\"></div><div class=\"line\">    // Convert the NSString to NSData to meet the requirements for the value type kSecValueData.</div><div class=\"line\">    // This is where to store sensitive data that should be encrypted.</div><div class=\"line\">    NSString *passwordString = [dictionaryToConvert objectForKey:(id)kSecValueData];</div><div class=\"line\">    [returnDictionary setObject:[passwordString dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData];</div><div class=\"line\"></div><div class=\"line\">    return returnDictionary;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert</div><div class=\"line\">&#123;</div><div class=\"line\">    // The assumption is that this method will be called with a properly populated dictionary</div><div class=\"line\">    // containing all the right key/value pairs for the UI element.</div><div class=\"line\"></div><div class=\"line\">    // Create a dictionary to return populated with the attributes and data.</div><div class=\"line\">    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];</div><div class=\"line\"></div><div class=\"line\">    // Add the proper search key and class attribute.</div><div class=\"line\">    [returnDictionary setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];</div><div class=\"line\">    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];</div><div class=\"line\"></div><div class=\"line\">    // Acquire the password data from the attributes.</div><div class=\"line\">    NSData *passwordData = NULL;</div><div class=\"line\">    if (SecItemCopyMatching((CFDictionaryRef)returnDictionary, (CFTypeRef *)&amp;passwordData) == noErr)</div><div class=\"line\">    &#123;</div><div class=\"line\">        // Remove the search, class, and identifier key/value, we don&apos;t need them anymore.</div><div class=\"line\">        [returnDictionary removeObjectForKey:(id)kSecReturnData];</div><div class=\"line\"></div><div class=\"line\">        // Add the password to the dictionary, converting from NSData to NSString.</div><div class=\"line\">        NSString *password = [[[NSString alloc] initWithBytes:[passwordData bytes] length:[passwordData length] </div><div class=\"line\">                                                     encoding:NSUTF8StringEncoding] autorelease];</div><div class=\"line\">        [returnDictionary setObject:password forKey:(id)kSecValueData];</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        // Don&apos;t do anything if nothing is found.</div><div class=\"line\">        NSAssert(NO, @&quot;Serious error, no matching item found in the keychain.\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    [passwordData release];</div><div class=\"line\"></div><div class=\"line\">    return returnDictionary;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)writeToKeychain</div><div class=\"line\">&#123;</div><div class=\"line\">    NSDictionary *attributes = NULL;</div><div class=\"line\">    NSMutableDictionary *updateItem = NULL;</div><div class=\"line\">    OSStatus result;</div><div class=\"line\"></div><div class=\"line\">    if (SecItemCopyMatching((CFDictionaryRef)genericPasswordQuery, (CFTypeRef *)&amp;attributes) == noErr)</div><div class=\"line\">    &#123;</div><div class=\"line\">        // First we need the attributes from the Keychain.</div><div class=\"line\">        updateItem = [NSMutableDictionary dictionaryWithDictionary:attributes];</div><div class=\"line\">        // Second we need to add the appropriate search key/values.</div><div class=\"line\">        [updateItem setObject:[genericPasswordQuery objectForKey:(id)kSecClass] forKey:(id)kSecClass];</div><div class=\"line\"></div><div class=\"line\">        // Lastly, we need to set up the updated attribute list being careful to remove the class.</div><div class=\"line\">        NSMutableDictionary *tempCheck = [self dictionaryToSecItemFormat:keychainItemData];</div><div class=\"line\">        [tempCheck removeObjectForKey:(id)kSecClass];</div><div class=\"line\"></div><div class=\"line\">#if TARGET_IPHONE_SIMULATOR</div><div class=\"line\">        // Remove the access group if running on the iPhone simulator.</div><div class=\"line\">        // </div><div class=\"line\">        // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</div><div class=\"line\">        // for the simulator to check. This means that all apps can see all keychain items when run</div><div class=\"line\">        // on the simulator.</div><div class=\"line\">        //</div><div class=\"line\">        // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</div><div class=\"line\">        // simulator will return -25243 (errSecNoAccessForItem).</div><div class=\"line\">        //</div><div class=\"line\">        // The access group attribute will be included in items returned by SecItemCopyMatching,</div><div class=\"line\">        // which is why we need to remove it before updating the item.</div><div class=\"line\">        [tempCheck removeObjectForKey:(id)kSecAttrAccessGroup];</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">        // An implicit assumption is that you can only update a single item at a time.</div><div class=\"line\"></div><div class=\"line\">        result = SecItemUpdate((CFDictionaryRef)updateItem, (CFDictionaryRef)tempCheck);</div><div class=\"line\">        NSAssert( result == noErr, @&quot;Couldn&apos;t update the Keychain Item.&quot; );</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        // No previous item found; add the new one.</div><div class=\"line\">        result = SecItemAdd((CFDictionaryRef)[self dictionaryToSecItemFormat:keychainItemData], NULL);</div><div class=\"line\">        NSAssert( result == noErr, @&quot;Couldn&apos;t add the Keychain Item.&quot; );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>我们在写一个工具类用来保存UUID到keychain和从keychain中读取UUID.</p>\n<p><strong>实现代码</strong>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark - 保存和读取UUID</div><div class=\"line\">+(void)saveUUIDToKeyChain&#123;</div><div class=\"line\">    KeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@&quot;Identfier&quot; service:@&quot;AppName&quot; accessGroup:nil];</div><div class=\"line\">    NSString *string = [keychainItem objectForKey: (__bridge id)kSecAttrGeneric];</div><div class=\"line\">    if([string isEqualToString:@&quot;&quot;] || !string)&#123;</div><div class=\"line\">        [keychainItem setObject:[self getUUIDString] forKey:(__bridge id)kSecAttrGeneric];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(NSString *)readUUIDFromKeyChain&#123;</div><div class=\"line\">    KeychainItemWrapper *keychainItemm = [[KeychainItemWrapper alloc] initWithAccount:@&quot;Identfier&quot; service:@&quot;AppName&quot; accessGroup:nil];</div><div class=\"line\">    NSString *UUID = [keychainItemm objectForKey: (__bridge id)kSecAttrGeneric];</div><div class=\"line\">    return UUID;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (NSString *)getUUIDString</div><div class=\"line\">&#123;</div><div class=\"line\">    CFUUIDRef uuidRef = CFUUIDCreate(kCFAllocatorDefault);</div><div class=\"line\">    CFStringRef strRef = CFUUIDCreateString(kCFAllocatorDefault , uuidRef);</div><div class=\"line\">    NSString *uuidString = [(__bridge NSString*)strRef stringByReplacingOccurrencesOfString:@&quot;-&quot; withString:@&quot;&quot;];</div><div class=\"line\">    CFRelease(strRef);</div><div class=\"line\">    CFRelease(uuidRef);</div><div class=\"line\">    return uuidString;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>写入UUID到keychain</p>\n<p>我们最好在程序启动之后把UUID写入到keychain，代码如下：\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class=\"line\">&#123;</div><div class=\"line\">    [AppUtils saveUUIDToKeyChain];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>读取UUID</p>\n<p>在需要读取的地方直接调用AppUtils的类方法readUUIDFromKeyChain即可。</p>\n<hr>\n<p>1.让同一开发商的所有APP在同一台设备上获取到UUID相同</p>\n<p>在每个APP的项目里面做如下设置</p>\n<p>1.1、设置accessgroup\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">keychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@&quot;Identfier&quot; service:@&quot;AppName&quot; accessGroup:@&quot;YOUR_BUNDLE_SEED.com.yourcompany.userinfo&quot;];</div></pre></td></tr></table></figure></p>\n<p>1.2、创建plist文件</p>\n<p>然后在项目相同的目录下创建KeychainAccessGroups.plist文件。</p>\n<p>该文件的结构是一个字典，其中中最顶层的节点必须是一个键为“keychain-access-groups”的Array，并且该Array中每一项都是一个描述分组的NSString。YOUR_BUNDLE_SEED.com.yourcompany.userinfo就是要设置的组名。</p>\n<p>如图:\n<img src=\"/img/277755-72008ba008a56557.png\" alt=\"\">\n1.3、 设置code signing</p>\n<p>接着在Target---&gt;Build Settings----&gt;Code Signing栏下的Code Signing Entitlements右侧添加KeychainAccessGroups.plist</p>\n<p>如图：\n<img src=\"/img/277755-e736892057d71333.png\" alt=\"\"></p>\n<p>这样就可以保证每个app都是从keychain中读取出来同一个UUID</p>\n","excerpt":"","more":"<p>在开发过程中，我们经常会被要求获取每个设备的唯一标示，以便后台做相应的处理。我们来看看有哪些方法来获取设备的唯一标示，然后再分析下这些方法的利弊。</p>\n<p>具体可以分为如下几种：</p>\n<ol>\n<li>UDID</li>\n<li>IDFA</li>\n<li>IDFV</li>\n<li>MAC</li>\n<li>keychain</li>\n</ol>\n<hr>\n<p>下面我们来具体分析下每种获取方法的利弊</p>\n<h3>1、UDID</h3>\n<p>什么是UDID</p>\n<p>UDID 「Unique Device Identifier Description」是由子母和数字组成的40个字符串的序号，用来区别每一个唯一的iOS设备，包括 iPhones, iPads, 以及 iPod touches，这些编码看起来是随机的，实际上是跟硬件设备特点相联系的，另外你可以到iTunes，pp助手或itools等软件查看你的udid（设备标识）</p>\n<p>UDID是用来干什么的？</p>\n<p>UDID可以关联其它各种数据到相关设备上。例如，连接到开发者账号，可以允许在发布前让设备安装或测试应用；也可以让开发者获得iOS测试版进行体验。苹果用UDID连接到苹果的ID，这些设备可以自动下载和安装从App Store购买的应用、保存从iTunes购买的音乐、帮助苹果发送推送通知、即时消息。 在iOS 应用早期，UDID被第三方应用开发者和网络广告商用来收集用户数据，可以用来关联地址、记录应用使用习惯……以便推送精准广告。</p>\n<p>为什么苹果反对开发人员使用UDID？</p>\n<p>iOS 2.0版本以后UIDevice提供一个获取设备唯一标识符的方法uniqueIdentifier，通过该方法我们可以获取设备的序列号，这个也是目前为止唯一可以确认唯一的标示符。 许多开发者把UDID跟用户的真实姓名、密码、住址、其它数据关联起来；网络窥探者会从多个应用收集这些数据，然后顺藤摸瓜得到这个人的许多隐私数据。同时大部分应用确实在频繁传输UDID和私人信息。 为了避免集体诉讼，苹果最终决定在iOS 5 的时候，将这一惯例废除，开发者被引导生成一个唯一的标识符，只能检测应用程序，其他的信息不提供。现在应用试图获取UDID已被禁止且不允许上架。</p>\n<p>所以这个方法作废</p>\n<h3>2、IDFA</h3>\n<p>全名：advertisingIdentifier</p>\n<p>获取代码：\n<code>#import &lt;AdSupport/AdSupport.h&gt; NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];</code>\n来源：iOS6.0及以后</p>\n<p>说明：直译就是广告id， 在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪 里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。</p>\n<p>注意：由于idfa会出现取不到的情况，故绝不可以作为业务分析的主id，来识别用户。</p>\n<h3>3、IDFV</h3>\n<p>全名：identifierForVendor\n获取代码：\n<code>NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString];</code>\n来源：iOS6.0及以后</p>\n<p>说明：顾名思义，是给Vendor标识用户用的，每个设备在所属同一个Vender的应用里，都有相同的值。其中的Vender是指应用提供商，但准确点说，是通过BundleID的反转的前两部分进行匹配，如果相同就是同一个Vender，例如对于com.taobao.app1, com.taobao.app2 这两个BundleID来说，就属于同一个Vender，共享同一个idfv的值。和idfa不同的是，idfv的值是一定能取到的，所以非常适合于作为内部用户行为分析的主id，来标识用户，替代OpenUDID。</p>\n<p>注意：如果用户将属于此Vender的所有App卸载，则idfv的值会被重置，即再重装此Vender的App，idfv的值和之前不同。</p>\n<h3>4、MAC地址</h3>\n<p>使用WiFi的mac地址来取代已经废弃了的uniqueIdentifier方法。具体可见:\nhttp://stackoverflow.com/questions/677530/how-can-i-programmatically-get-the-mac-address-of-an-iphone</p>\n<p>然而在iOS 7中苹果再一次无情的封杀mac地址，使用之前的方法获取到的mac地址全部都变成了02:00:00:00:00:00。</p>\n<h3>5、Keychain</h3>\n<p><img src=\"/img/277755-807a54b6dcbeb347.png\" alt=\"\"></p>\n<p>我们可以获取到UUID，然后把UUID保存到KeyChain里面。</p>\n<p>这样以后即使APP删了再装回来，也可以从KeyChain中读取回来。使用group还可以可以保证同一个开发商的所有程序针对同一台设备能够获取到相同的不变的UDID。</p>\n<p>但是刷机或重装系统后uuid还是会改变。</p>\n<p>把下面两个类文件放到你的项目中\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">KeychainItemWrapper.h文件</div><div class=\"line\">********************************</div><div class=\"line\"></div><div class=\"line\">#import &lt;UIKit/UIKit.h&gt;</div><div class=\"line\"></div><div class=\"line\">@interface KeychainItemWrapper : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">    NSMutableDictionary *keychainItemData;        // The actual keychain item data backing store.</div><div class=\"line\">    NSMutableDictionary *genericPasswordQuery;    // A placeholder for the generic keychain item query used to locate the item.</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, retain) NSMutableDictionary *keychainItemData;</div><div class=\"line\">@property (nonatomic, retain) NSMutableDictionary *genericPasswordQuery;</div><div class=\"line\"></div><div class=\"line\">// Designated initializer.</div><div class=\"line\">- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;</div><div class=\"line\">- (void)setObject:(id)inObject forKey:(id)key;</div><div class=\"line\">- (id)objectForKey:(id)key;</div><div class=\"line\"></div><div class=\"line\">// Initializes and resets the default generic keychain item data.</div><div class=\"line\">- (void)resetKeychainItem;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div></pre></td><td class=\"code\"><pre><div class=\"line\">KeychainItemWrapper.h文件</div><div class=\"line\">********************************</div><div class=\"line\"></div><div class=\"line\">#import &quot;KeychainItemWrapper.h&quot;</div><div class=\"line\">#import &lt;Security/Security.h&gt;</div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\"></div><div class=\"line\">These are the default constants and their respective types,</div><div class=\"line\">available for the kSecClassGenericPassword Keychain Item class:</div><div class=\"line\"></div><div class=\"line\">kSecAttrAccessGroup            -        CFStringRef</div><div class=\"line\">kSecAttrCreationDate        -        CFDateRef</div><div class=\"line\">kSecAttrModificationDate    -        CFDateRef</div><div class=\"line\">kSecAttrDescription            -        CFStringRef</div><div class=\"line\">kSecAttrComment                -        CFStringRef</div><div class=\"line\">kSecAttrCreator                -        CFNumberRef</div><div class=\"line\">kSecAttrType                -        CFNumberRef</div><div class=\"line\">kSecAttrLabel                -        CFStringRef</div><div class=\"line\">kSecAttrIsInvisible            -        CFBooleanRef</div><div class=\"line\">kSecAttrIsNegative            -        CFBooleanRef</div><div class=\"line\">kSecAttrAccount                -        CFStringRef</div><div class=\"line\">kSecAttrService                -        CFStringRef</div><div class=\"line\">kSecAttrGeneric                -        CFDataRef</div><div class=\"line\"></div><div class=\"line\">See the header file Security/SecItem.h for more details.</div><div class=\"line\"></div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\">@interface KeychainItemWrapper (PrivateMethods)</div><div class=\"line\">/*</div><div class=\"line\">The decision behind the following two methods (secItemFormatToDictionary and dictionaryToSecItemFormat) was</div><div class=\"line\">to encapsulate the transition between what the detail view controller was expecting (NSString *) and what the</div><div class=\"line\">Keychain API expects as a validly constructed container class.</div><div class=\"line\">*/</div><div class=\"line\">- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert;</div><div class=\"line\">- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert;</div><div class=\"line\"></div><div class=\"line\">// Updates the item in the keychain, or adds it if it doesn&apos;t exist.</div><div class=\"line\">- (void)writeToKeychain;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation KeychainItemWrapper</div><div class=\"line\"></div><div class=\"line\">@synthesize keychainItemData, genericPasswordQuery;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self = [super init])</div><div class=\"line\">    &#123;</div><div class=\"line\">        NSAssert(account != nil || service != nil, @&quot;Both account and service are nil.  Must specifiy at least one.&quot;);</div><div class=\"line\">        // Begin Keychain search setup. The genericPasswordQuery the attributes kSecAttrAccount and</div><div class=\"line\">        // kSecAttrService are used as unique identifiers differentiating keychain items from one another</div><div class=\"line\">        genericPasswordQuery = [[NSMutableDictionary alloc] init];</div><div class=\"line\"></div><div class=\"line\">        [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];</div><div class=\"line\"></div><div class=\"line\">        [genericPasswordQuery setObject:account forKey:(id)kSecAttrAccount];</div><div class=\"line\">        [genericPasswordQuery setObject:service forKey:(id)kSecAttrService];</div><div class=\"line\"></div><div class=\"line\">        // The keychain access group attribute determines if this item can be shared</div><div class=\"line\">        // amongst multiple apps whose code signing entitlements contain the same keychain access group.</div><div class=\"line\">        if (accessGroup != nil)</div><div class=\"line\">        &#123;</div><div class=\"line\">#if TARGET_IPHONE_SIMULATOR</div><div class=\"line\">            // Ignore the access group if running on the iPhone simulator.</div><div class=\"line\">            //</div><div class=\"line\">            // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</div><div class=\"line\">            // for the simulator to check. This means that all apps can see all keychain items when run</div><div class=\"line\">            // on the simulator.</div><div class=\"line\">            //</div><div class=\"line\">            // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</div><div class=\"line\">            // simulator will return -25243 (errSecNoAccessForItem).</div><div class=\"line\">#else</div><div class=\"line\">            [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Use the proper search constants, return only the attributes of the first match.</div><div class=\"line\">        [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];</div><div class=\"line\">        [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];</div><div class=\"line\"></div><div class=\"line\">        NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];</div><div class=\"line\"></div><div class=\"line\">        NSMutableDictionary *outDictionary = nil;</div><div class=\"line\"></div><div class=\"line\">        if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;outDictionary) == noErr)</div><div class=\"line\">        &#123;</div><div class=\"line\">            // Stick these default values into keychain item if nothing found.</div><div class=\"line\">            [self resetKeychainItem];</div><div class=\"line\"></div><div class=\"line\">            //Adding the account and service identifiers to the keychain</div><div class=\"line\">            [keychainItemData setObject:account forKey:(id)kSecAttrAccount];</div><div class=\"line\">            [keychainItemData setObject:service forKey:(id)kSecAttrService];</div><div class=\"line\"></div><div class=\"line\">            if (accessGroup != nil)</div><div class=\"line\">            &#123;</div><div class=\"line\">#if TARGET_IPHONE_SIMULATOR</div><div class=\"line\">                // Ignore the access group if running on the iPhone simulator.</div><div class=\"line\">                //</div><div class=\"line\">                // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</div><div class=\"line\">                // for the simulator to check. This means that all apps can see all keychain items when run</div><div class=\"line\">                // on the simulator.</div><div class=\"line\">                //</div><div class=\"line\">                // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</div><div class=\"line\">                // simulator will return -25243 (errSecNoAccessForItem).</div><div class=\"line\">#else</div><div class=\"line\">                [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];</div><div class=\"line\">#endif</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">            // load the saved data from Keychain.</div><div class=\"line\">            self.keychainItemData = [self secItemFormatToDictionary:outDictionary];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        [outDictionary release];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self = [super init])</div><div class=\"line\">    &#123;</div><div class=\"line\">        // Begin Keychain search setup. The genericPasswordQuery leverages the special user</div><div class=\"line\">        // defined attribute kSecAttrGeneric to distinguish itself between other generic Keychain</div><div class=\"line\">        // items which may be included by the same application.</div><div class=\"line\">        genericPasswordQuery = [[NSMutableDictionary alloc] init];</div><div class=\"line\"></div><div class=\"line\">        [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];</div><div class=\"line\">        [genericPasswordQuery setObject:identifier forKey:(id)kSecAttrGeneric];</div><div class=\"line\"></div><div class=\"line\">        // The keychain access group attribute determines if this item can be shared</div><div class=\"line\">        // amongst multiple apps whose code signing entitlements contain the same keychain access group.</div><div class=\"line\">        if (accessGroup != nil)</div><div class=\"line\">        &#123;</div><div class=\"line\">#if TARGET_IPHONE_SIMULATOR</div><div class=\"line\">            // Ignore the access group if running on the iPhone simulator.</div><div class=\"line\">            // </div><div class=\"line\">            // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</div><div class=\"line\">            // for the simulator to check. This means that all apps can see all keychain items when run</div><div class=\"line\">            // on the simulator.</div><div class=\"line\">            //</div><div class=\"line\">            // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</div><div class=\"line\">            // simulator will return -25243 (errSecNoAccessForItem).</div><div class=\"line\">#else            </div><div class=\"line\">            [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Use the proper search constants, return only the attributes of the first match.</div><div class=\"line\">        [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];</div><div class=\"line\">        [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];</div><div class=\"line\"></div><div class=\"line\">        NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];</div><div class=\"line\"></div><div class=\"line\">        NSMutableDictionary *outDictionary = nil;</div><div class=\"line\"></div><div class=\"line\">        if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;outDictionary) == noErr)</div><div class=\"line\">        &#123;</div><div class=\"line\">            // Stick these default values into keychain item if nothing found.</div><div class=\"line\">            [self resetKeychainItem];</div><div class=\"line\"></div><div class=\"line\">            // Add the generic attribute and the keychain access group.</div><div class=\"line\">            [keychainItemData setObject:identifier forKey:(id)kSecAttrGeneric];</div><div class=\"line\">            if (accessGroup != nil)</div><div class=\"line\">            &#123;</div><div class=\"line\">#if TARGET_IPHONE_SIMULATOR</div><div class=\"line\">                // Ignore the access group if running on the iPhone simulator.</div><div class=\"line\">                // </div><div class=\"line\">                // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</div><div class=\"line\">                // for the simulator to check. This means that all apps can see all keychain items when run</div><div class=\"line\">                // on the simulator.</div><div class=\"line\">                //</div><div class=\"line\">                // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</div><div class=\"line\">                // simulator will return -25243 (errSecNoAccessForItem).</div><div class=\"line\">#else            </div><div class=\"line\">                [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];</div><div class=\"line\">#endif</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">            // load the saved data from Keychain.</div><div class=\"line\">            self.keychainItemData = [self secItemFormatToDictionary:outDictionary];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        [outDictionary release];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)dealloc</div><div class=\"line\">&#123;</div><div class=\"line\">    [keychainItemData release];</div><div class=\"line\">    [genericPasswordQuery release];</div><div class=\"line\"></div><div class=\"line\">    [super dealloc];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setObject:(id)inObject forKey:(id)key </div><div class=\"line\">&#123;</div><div class=\"line\">    if (inObject == nil) return;</div><div class=\"line\">    id currentObject = [keychainItemData objectForKey:key];</div><div class=\"line\">    if (![currentObject isEqual:inObject])</div><div class=\"line\">    &#123;</div><div class=\"line\">        [keychainItemData setObject:inObject forKey:key];</div><div class=\"line\">        [self writeToKeychain];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)objectForKey:(id)key</div><div class=\"line\">&#123;</div><div class=\"line\">    return [keychainItemData objectForKey:key];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)resetKeychainItem</div><div class=\"line\">&#123;</div><div class=\"line\">    OSStatus junk = noErr;</div><div class=\"line\">    if (!keychainItemData) </div><div class=\"line\">    &#123;</div><div class=\"line\">        self.keychainItemData = [[NSMutableDictionary alloc] init];</div><div class=\"line\">    &#125;</div><div class=\"line\">    else if (keychainItemData)</div><div class=\"line\">    &#123;</div><div class=\"line\">        NSMutableDictionary *tempDictionary = [self dictionaryToSecItemFormat:keychainItemData];</div><div class=\"line\">        junk = SecItemDelete((CFDictionaryRef)tempDictionary);</div><div class=\"line\">        NSAssert( junk == noErr || junk == errSecItemNotFound, @&quot;Problem deleting current dictionary.&quot; );</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Default attributes for keychain item.</div><div class=\"line\">    [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecAttrAccount];</div><div class=\"line\">    [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecAttrLabel];</div><div class=\"line\">    [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecAttrDescription];</div><div class=\"line\"></div><div class=\"line\">    // Default data for keychain item.</div><div class=\"line\">    [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecValueData];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert</div><div class=\"line\">&#123;</div><div class=\"line\">    // The assumption is that this method will be called with a properly populated dictionary</div><div class=\"line\">    // containing all the right key/value pairs for a SecItem.</div><div class=\"line\"></div><div class=\"line\">    // Create a dictionary to return populated with the attributes and data.</div><div class=\"line\">    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];</div><div class=\"line\"></div><div class=\"line\">    // Add the Generic Password keychain item class attribute.</div><div class=\"line\">    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];</div><div class=\"line\"></div><div class=\"line\">    // Convert the NSString to NSData to meet the requirements for the value type kSecValueData.</div><div class=\"line\">    // This is where to store sensitive data that should be encrypted.</div><div class=\"line\">    NSString *passwordString = [dictionaryToConvert objectForKey:(id)kSecValueData];</div><div class=\"line\">    [returnDictionary setObject:[passwordString dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData];</div><div class=\"line\"></div><div class=\"line\">    return returnDictionary;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert</div><div class=\"line\">&#123;</div><div class=\"line\">    // The assumption is that this method will be called with a properly populated dictionary</div><div class=\"line\">    // containing all the right key/value pairs for the UI element.</div><div class=\"line\"></div><div class=\"line\">    // Create a dictionary to return populated with the attributes and data.</div><div class=\"line\">    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];</div><div class=\"line\"></div><div class=\"line\">    // Add the proper search key and class attribute.</div><div class=\"line\">    [returnDictionary setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];</div><div class=\"line\">    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];</div><div class=\"line\"></div><div class=\"line\">    // Acquire the password data from the attributes.</div><div class=\"line\">    NSData *passwordData = NULL;</div><div class=\"line\">    if (SecItemCopyMatching((CFDictionaryRef)returnDictionary, (CFTypeRef *)&amp;passwordData) == noErr)</div><div class=\"line\">    &#123;</div><div class=\"line\">        // Remove the search, class, and identifier key/value, we don&apos;t need them anymore.</div><div class=\"line\">        [returnDictionary removeObjectForKey:(id)kSecReturnData];</div><div class=\"line\"></div><div class=\"line\">        // Add the password to the dictionary, converting from NSData to NSString.</div><div class=\"line\">        NSString *password = [[[NSString alloc] initWithBytes:[passwordData bytes] length:[passwordData length] </div><div class=\"line\">                                                     encoding:NSUTF8StringEncoding] autorelease];</div><div class=\"line\">        [returnDictionary setObject:password forKey:(id)kSecValueData];</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        // Don&apos;t do anything if nothing is found.</div><div class=\"line\">        NSAssert(NO, @&quot;Serious error, no matching item found in the keychain.\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    [passwordData release];</div><div class=\"line\"></div><div class=\"line\">    return returnDictionary;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)writeToKeychain</div><div class=\"line\">&#123;</div><div class=\"line\">    NSDictionary *attributes = NULL;</div><div class=\"line\">    NSMutableDictionary *updateItem = NULL;</div><div class=\"line\">    OSStatus result;</div><div class=\"line\"></div><div class=\"line\">    if (SecItemCopyMatching((CFDictionaryRef)genericPasswordQuery, (CFTypeRef *)&amp;attributes) == noErr)</div><div class=\"line\">    &#123;</div><div class=\"line\">        // First we need the attributes from the Keychain.</div><div class=\"line\">        updateItem = [NSMutableDictionary dictionaryWithDictionary:attributes];</div><div class=\"line\">        // Second we need to add the appropriate search key/values.</div><div class=\"line\">        [updateItem setObject:[genericPasswordQuery objectForKey:(id)kSecClass] forKey:(id)kSecClass];</div><div class=\"line\"></div><div class=\"line\">        // Lastly, we need to set up the updated attribute list being careful to remove the class.</div><div class=\"line\">        NSMutableDictionary *tempCheck = [self dictionaryToSecItemFormat:keychainItemData];</div><div class=\"line\">        [tempCheck removeObjectForKey:(id)kSecClass];</div><div class=\"line\"></div><div class=\"line\">#if TARGET_IPHONE_SIMULATOR</div><div class=\"line\">        // Remove the access group if running on the iPhone simulator.</div><div class=\"line\">        // </div><div class=\"line\">        // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</div><div class=\"line\">        // for the simulator to check. This means that all apps can see all keychain items when run</div><div class=\"line\">        // on the simulator.</div><div class=\"line\">        //</div><div class=\"line\">        // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</div><div class=\"line\">        // simulator will return -25243 (errSecNoAccessForItem).</div><div class=\"line\">        //</div><div class=\"line\">        // The access group attribute will be included in items returned by SecItemCopyMatching,</div><div class=\"line\">        // which is why we need to remove it before updating the item.</div><div class=\"line\">        [tempCheck removeObjectForKey:(id)kSecAttrAccessGroup];</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">        // An implicit assumption is that you can only update a single item at a time.</div><div class=\"line\"></div><div class=\"line\">        result = SecItemUpdate((CFDictionaryRef)updateItem, (CFDictionaryRef)tempCheck);</div><div class=\"line\">        NSAssert( result == noErr, @&quot;Couldn&apos;t update the Keychain Item.&quot; );</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        // No previous item found; add the new one.</div><div class=\"line\">        result = SecItemAdd((CFDictionaryRef)[self dictionaryToSecItemFormat:keychainItemData], NULL);</div><div class=\"line\">        NSAssert( result == noErr, @&quot;Couldn&apos;t add the Keychain Item.&quot; );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>我们在写一个工具类用来保存UUID到keychain和从keychain中读取UUID.</p>\n<p><strong>实现代码</strong>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark - 保存和读取UUID</div><div class=\"line\">+(void)saveUUIDToKeyChain&#123;</div><div class=\"line\">    KeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@&quot;Identfier&quot; service:@&quot;AppName&quot; accessGroup:nil];</div><div class=\"line\">    NSString *string = [keychainItem objectForKey: (__bridge id)kSecAttrGeneric];</div><div class=\"line\">    if([string isEqualToString:@&quot;&quot;] || !string)&#123;</div><div class=\"line\">        [keychainItem setObject:[self getUUIDString] forKey:(__bridge id)kSecAttrGeneric];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(NSString *)readUUIDFromKeyChain&#123;</div><div class=\"line\">    KeychainItemWrapper *keychainItemm = [[KeychainItemWrapper alloc] initWithAccount:@&quot;Identfier&quot; service:@&quot;AppName&quot; accessGroup:nil];</div><div class=\"line\">    NSString *UUID = [keychainItemm objectForKey: (__bridge id)kSecAttrGeneric];</div><div class=\"line\">    return UUID;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (NSString *)getUUIDString</div><div class=\"line\">&#123;</div><div class=\"line\">    CFUUIDRef uuidRef = CFUUIDCreate(kCFAllocatorDefault);</div><div class=\"line\">    CFStringRef strRef = CFUUIDCreateString(kCFAllocatorDefault , uuidRef);</div><div class=\"line\">    NSString *uuidString = [(__bridge NSString*)strRef stringByReplacingOccurrencesOfString:@&quot;-&quot; withString:@&quot;&quot;];</div><div class=\"line\">    CFRelease(strRef);</div><div class=\"line\">    CFRelease(uuidRef);</div><div class=\"line\">    return uuidString;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>写入UUID到keychain</p>\n<p>我们最好在程序启动之后把UUID写入到keychain，代码如下：\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class=\"line\">&#123;</div><div class=\"line\">    [AppUtils saveUUIDToKeyChain];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>读取UUID</p>\n<p>在需要读取的地方直接调用AppUtils的类方法readUUIDFromKeyChain即可。</p>\n<hr>\n<p>1.让同一开发商的所有APP在同一台设备上获取到UUID相同</p>\n<p>在每个APP的项目里面做如下设置</p>\n<p>1.1、设置accessgroup\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">keychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@&quot;Identfier&quot; service:@&quot;AppName&quot; accessGroup:@&quot;YOUR_BUNDLE_SEED.com.yourcompany.userinfo&quot;];</div></pre></td></tr></table></figure></p>\n<p>1.2、创建plist文件</p>\n<p>然后在项目相同的目录下创建KeychainAccessGroups.plist文件。</p>\n<p>该文件的结构是一个字典，其中中最顶层的节点必须是一个键为“keychain-access-groups”的Array，并且该Array中每一项都是一个描述分组的NSString。YOUR_BUNDLE_SEED.com.yourcompany.userinfo就是要设置的组名。</p>\n<p>如图:\n<img src=\"/img/277755-72008ba008a56557.png\" alt=\"\">\n1.3、 设置code signing</p>\n<p>接着在Target---&gt;Build Settings----&gt;Code Signing栏下的Code Signing Entitlements右侧添加KeychainAccessGroups.plist</p>\n<p>如图：\n<img src=\"/img/277755-e736892057d71333.png\" alt=\"\"></p>\n<p>这样就可以保证每个app都是从keychain中读取出来同一个UUID</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}